{"pages":[{"title":"关于","text":"","link":"/about/index.html"}],"posts":[{"title":"建站踩坑指南","text":"本站搭建在腾讯云实例上，使用了docker构建了node、hexo、redis、mysql、php-fpm实例 其中大部分容器镜像为手动构建，并使用了docker-compose进行了容器编排 本文记录在搭建站点过程中的坑与解决方案 本站docker环境git地址：https://gitee.com/liangwt_admin/docker_env本站博文git地址：https://gitee.com/liangwt_admin/hexo_blog git将空文件夹加入到版本控制git只对文件进行版本控制，当一个文件夹为空或者 将文件夹 /logs/* 写入.gitignore 中，会导致这个文件夹并不会被纳入版本控制但是为了保持文件结构我们需要保留空文件夹所以可以在空文件夹下创建一个.gitkeep 或 .keep 文件，并在.gitignore 加入!.gitkeep这样就会把空文件夹加入到git中 腾讯安全组策略腾讯云控制台可以设置安全组策略，其中一个默认策略并没有加入6973（redis默认）端口 即使没有开放对应端口，tcp的syn 请求依旧能够打入机器，但是并不能建立连接，推测原因为腾讯云安全组策略为虚拟包过滤防火墙 root@VM-0-10-ubuntu:/data# netstat -catnp | grep :6379tcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnettcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnettcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnettcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnet netstats 只显示tcp6root@VM-0-10-ubuntu:/data# netstat -anptActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 981/sshdtcp 0 344 172.21.0.10:22 218.30.113.39:61883 ESTABLISHED 29283/sshd: ubuntutcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp6 0 0 :::80 :::* LISTEN 19795/docker-proxytcp6 0 0 :::443 :::* LISTEN 19742/docker-proxy 发现redis只监听了tcp6端口，最后发现如下结论：netstat 只是很真实的显示监听的端口而已，但是需要注意 ipv6 实际上在 Linux 上也支持 ipv4。 参考 http://www.cnblogs.com/wlzjdm/p/8684202.html","link":"/2018/04/25/build_site/"},{"title":"理解BFC特性","text":"在解释BFC之前，先说一下文档流。 我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。 常见的FC有BFC、IFC，还有GFC和FFC。BFC是block formatting context，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域 触发 BFC只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC 特性及应用 同一个 BFC 下外边距会发生折叠 BFC 可以包含浮动的元素（清除浮动） 我相信大家经常会遇到一个容器里有浮动元素，但是这个容器的高度却是0的场景，如下图： 看下面的例子： &lt;div class=\"container\"&gt; &lt;div&gt;Sibling&lt;/div&gt; &lt;div&gt;Sibling&lt;/div&gt;&lt;/div&gt; .container { background-color: green;} .container div { float: left; background-color: lightgreen; margin: 10px;} 结果： 在上边的情形中，container是不会有高度的，因为它包含了浮动元素。通常我们解决这个问题的办法是利用一个伪元素去实现clear fix，但是现在我们有了更好的解决办法，即利用BFC，因为它够容纳浮动元素的。 我们现在让container形成BFC规则，结果如下： .container { overflow: hidden; /* creates block formatting context */ background-color: green;} .container div { float: left; background-color: lightgreen; margin: 10px;} 结果： BFC 可以阻止元素被浮动元素覆盖 参考链接 理解CSS中的BFC(块级可视化上下文) 深入理解BFC 布局概念 关于CSS-BFC深入理解","link":"/2018/05/25/CSS_BFC/"},{"title":"使用DOM解析来实现PHP模版引擎","text":"0. 前言: 传统模版语法的不利之处目前市面上有很多PHP的模版引擎, 如smarty、blade等. 其中大部分都是基于正则表达式将其中的模版语法转换成PHP代码, 并进行缓存. 模版代码所经历的过程如下: template -&gt; php -&gt; html 使用正则替换或者直接使用PHP原生有什么问题呢? 以下我们以blade为例来看一些具体例子: &lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;div class=\"items\" &gt; @if (count($records) === 1) &lt;p&gt;我有一个记录！&lt;/p&gt; @elseif (count($records) &gt; 1) &lt;p&gt;我有多个记录！&lt;/p&gt; @else &lt;p&gt;我没有任何记录！&lt;/p&gt; @endif &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 问题一: 编辑器格式化和语法高亮的问题如上, 我们面临的第一个问题是html和blade语法混杂在一起. 在阅读逻辑上, 我们需要来回的在blade和html之间做转化.当然, 当你熟悉了blade的语法并熟练掌握这个能力的时候, 这种转化并不会对你的阅读构成障碍.但是, 对于编辑器来说, 如果不使用合适的插件, 无论是代码高亮还是自动格式化都会产生意想不到结果 问题二: html中渲染class等属性其实以上还不是最令人眼花缭乱的,在我有限的工作经历中, 使用PHP渲染html中的class或者其他属性时, 经常会看到如下令人恐怖的代码 &lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;ul class=\"items\" &gt; &lt;li &lt;?= $cur==1 ? 'class=\"active\"' : ''?&gt;&gt;NO.1&lt;/li&gt; &lt;li &lt;?= $cur==2 ? 'class=\"active\"' : ''?&gt;&gt;NO.2&lt;/li&gt; &lt;li &lt;?= $cur==3 ? 'class=\"active\"' : ''?&gt;&gt;NO.3&lt;/li&gt; &lt;li &lt;?= $cur==4 ? 'class=\"active\"' : ''?&gt;&gt;NO.4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上还不是最恐怖的, 当有的人既不使用&lt;?= ?&gt;又不使用三元运算时…简直不可想象. 问题三: 公共模版中代码代码的不完整对于大部分网页的头部和尾部,我们单独抽离出来以供复用. 对于blade这种支持类似插槽的模版引擎,情况并不算太糟, 单对于不支持类似特性的模版引擎, 如下的代码也是非常常见 #./header.phtml 头文件&lt;html&gt;&lt;body&gt; &lt;div class=\"nav\"&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; #./bottom.phtml 尾文件 &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如上的问题在于什么呢, 每个部分模版都不是标签闭合的,每一部分并不完整. 在独立模版存在非常多的情况下, 正确的让html标签闭合也成为开发负担之一. 好了, 说完了这么多问题, 我们来想一想是否有解决的办法. 要知道以前前端js代码合并也是基于正则, 但是新的三大框架都是基于dom解析来实现. 那如果说, 我们在写php渲染页面的时候也可以和Vue一样, 使用类似如下的语法, 是不是就能解决以上的问题呢? 当然本文只是给大家提供一个最基本的思路, 和最基础的实现, 仅供娱乐和思路拓展吧. &lt;!-- ./tpl.html --&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;div class=\"title\"&gt; &lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt; &lt;/div&gt; &lt;div p-else&gt; &lt;p&gt;{{ vistor }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div p-for=\"(value, idx) in items\"&gt; &lt;p&gt;{{ value }} - {{ idx }}&lt;/p&gt; &lt;p&gt;{{ value }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; $params = [ \"is_author\" =&gt; true, \"author\" =&gt; \"liangwt\", \"vistor\" =&gt; \"Welcome\", \"items\" =&gt; [ \"A\", \"B\", \"C\", ],];csRender(\"./tpl.html\", $params); &lt;!-- out --&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;div class=\"title\"&gt; &lt;div&gt; &lt;p&gt;liangwt&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Welcome&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;A - 0&lt;/p&gt; &lt;p&gt;A&lt;/p&gt; &lt;p&gt;B - 1&lt;/p&gt; &lt;p&gt;B&lt;/p&gt; &lt;p&gt;C - 2&lt;/p&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1. DOM基本知识 D: Document 代表里文档 O: Object 代表了对象 M: Model 代表了模型 DOM把整个文档表示为一棵树, 确切的说是一个家谱树. 家谱树中我们使用 parent(父)、child(子)、sibling(兄弟)来描述成员之间的关系. 对于一个普通的如下的xml来说 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;bookstore&gt; &lt;book category=\"children\"&gt; &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category=\"cooking\"&gt; &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category=\"web\"&gt; &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;book category=\"web\"&gt; &lt;title lang=\"en\"&gt;XQuery Kick Start&lt;/title&gt; &lt;author&gt;James McGovern&lt;/author&gt; &lt;author&gt;Per Bothner&lt;/author&gt; &lt;author&gt;Kurt Cagle&lt;/author&gt; &lt;author&gt;James Linn&lt;/author&gt; &lt;author&gt;Vaidyanathan Nagarajan&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;49.99&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 我们可以生成如下的dom树结构 示例来源于知乎 2. PHP中DomDocument的使用PHP中原生提供了xml文档解析的拓展, 它使用起来非常简单. 网上资料大多介绍基于此拓展的封装包, 因此这里稍微详细介绍下. (1). DOM中的基类节点: The DOMNode class前面介绍dom树的时候说过, 文档是由不同类型的节点构成的集合, 所以DomDocument中绝大多数的类都继承于此. 它的类属性除了描述了自身名称($nodeName)、值($nodeValue)、类型($nodeType)等, 还描述了其父节点($parentNode)、子节点($childNodes)、同级节点($previousSibling、$nextSibling)等. 它的类方法除了包括对子节点的插入(appendChild())、替换(replaceChild())、 移除(removeChild())之外,还有诸多用于判断自身属性的函数. 作为任何类型的节点基类我们需要重点关注它的每一个属性和方法,参考官方文档. (2). 整个文档: DOMDocument extends DOMNodeDOMDocument继承自DOMNode, 它代表了整个文档, 也是整个文档树的根结点. 其中继承自基类的属性$nodeType是XML_DOCUMENT_NODE(9) 我们通常使用它的load*()来创建dom树,和save*()系列方法将dom转换成文本 我们的代码也是如此开头和结束 function csRender(string $tpl, array $params){ $dom = new DomDocument(\"1.0\", \"UTF-8\"); $dom-&gt;loadHTMLFile($tpl); // ... echo $dom-&gt;saveHTML();} (3). 元素节点 DOMElement extends DOMNodeDOMElement继承自DOMNode, 它代表了 之类的标签, 是构成dom结构的基本节点.其中标签的名字就是节点的属性tagName, 它的$nodeType是XML_ELEMENT_NODE = 1 元素可以包含其他的元素, 元素节点中也包含了其他类型的节点. 我们可以使用getAttributeNode() 或者getAttribute() 来获取元素节点的属性或者属性名,使用getElementsByTagName(string $name)获取元素包含的标签名$name为的节点.以及使用remove*()和set*()函数来删除和修改指定属性 我们在实现上面p-if的时候需要进行判断if条件是否成立,并在之后删除掉这个属性 if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\") { if ($if_result) { $item-&gt;removeAttribute(\"p-if\"); }} (4). 属性节点 DOMAttr extends DOMNodeDOMAttr继承自DOMNode, 它代表了标签class=&quot;one&quot;之类的属性, 如上面所讲对元素节点调用getAttributeNode()即可获取此元素的属性节点. 属性节点的nodeType是XML_ATTRIBUTE_NODE=2 (5). 文本节点 DOMText extends DOMCharacterDataDOMText继承自DOMCharacterData, DOMCharacterData也是继承自DOMNode. 在dom中它代表了元素节点包含的文本.其中nodeValue属性就是文本的内容. 文本节点的nodeType 是XML_TEXT_NODE = 3 除此之外需要知道的是, 文本节点单总是被包含在元素节点中, 文本节点的父节点是元素节点. 我们通过$elementNode-&gt;childNodes即可获取(如果有文本节点的话), 此函数返回的是 DOMNodeList 类型,它代表节点集合, 并实现了Traversable接口 我们在实现mustache语法的时候需要判断元素的文本节点中是否有{%raw%} {{ }} {%endraw%} 包裹的变量 if ($item-&gt;nodeType == XML_TEXT_NODE) { $str = preg_replace_callback('/\\{\\{(.*?)\\}\\}/', function ($matches) use ($params) { // ...处理逻辑 }, $item-&gt;nodeValue); $item-&gt;nodeValue = $str;} (6). 节点遍历以上就是最常用的几种节点类型了, 我们下面讲一讲如何进行节点遍历.我们需要基于遍历去实现树中节点判断, 然后进行树操作 我们在上面介绍了如何加载一个html文档,其中获取的变量$dom也是dom树的根结点 function csRender(string $tpl, array $params){ $dom = new DomDocument(\"1.0\", \"UTF-8\"); $dom-&gt;loadHTMLFile($tpl); traversingtDomNode($dom, $params); echo $dom-&gt;saveHTML();} 拥有一个节点之后如何遍历它的子节点呢, 我们获取其$domNode-&gt;childNodes子属性进行遍历即可 function traversingtDomNode($dom, $params){ foreach ($domNode-&gt;childNodes as $item) { //... }} 在遍历每一个节点过程中, 可以通过判断nodeType来对不同类型节点进行操作. 同时如果此节点依旧有子节点, 我们继续把节点放入此函数进行递归调用 function traversingtDomNode($dom, $params){ foreach ($domNode-&gt;childNodes as $item) { if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\")) { // ... } if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $item-&gt;hasAttribute(\"p-else\")) { // ... } if ($item-&gt;hasChildNodes()) { traversingtDomNode($item, $params); } }} 3. mustache语法实现{%raw%} {{ key }} {%endraw%} 语法实现很简单, 我们只要通过正则拿到{%raw%} {{ key }} {%endraw%}中的key值, 然后把连着{%raw%} {{ }} {%endraw%} 一起替换成$params[$key]即可 // ... if ($item-&gt;nodeType == XML_TEXT_NODE) { $str = preg_replace_callback('/\\{\\{(.*?)\\}\\}/', function ($matches) use ($params) { return $params[trim($matches[1])]; }, $item-&gt;nodeValue); $item-&gt;nodeValue = $str; }// ... 4. if语法实现&lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt;&lt;/div&gt; if语法实现也很简单, 我们通过$if_value =$item-&gt;getAttribute(&quot;p-if&quot;)获取属性值, 并通过判断$params[$if_value]`的值, 如果成立,则删掉属性, 展示此元素节点. 如果不成立则删掉此节点. // ... if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\")) { $if_result = $params[$if_value] ?? false; if ($if_result) { $item-&gt;removeAttribute(\"p-if\"); } else { array_push($elementsToRemove, $item); } }// ... 注意这里面有个小坑: 参考文档中的一条评论:在遍历中移除节点,会导致dom树重构,遍历终止. 所以我们采取将要移除的节点单独记录的方式,在循环结束后统一移除 $elementsToRemove = [];foreach ($domNode-&gt;childNodes as $item) { // ..}foreach ($elementsToRemove as $item) { $item-&gt;parentNode-&gt;removeChild($item);} 5. eles语法实现&lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt; &lt;div p-if=\"show_intro\"&gt; &lt;p&gt;{{ intro }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p p-else&gt; {{ vistor }} &lt;/p&gt;&lt;/div&gt; else 的实现会用到很有意思的技巧, 因为else的真值并不取决于它自身, 而是取决于和它配对的if的值. 注意!是和它配对的if值, 如果你想当然的认为是else之前的那个if值可就错咯. 我们看下面这个例子: &lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt; &lt;div p-if=\"show_intro_one\"&gt; &lt;p&gt;{{ intro_one }}&lt;/p&gt; &lt;/div&gt; &lt;div p-if=\"show_comment_one\"&gt; &lt;p&gt;{{ comment_one }}&lt;/p&gt; &lt;/div&gt; &lt;div p-else&gt; &lt;p&gt;{{ comment_two }}&lt;/p&gt; &lt;/div&gt; &lt;div p-else&gt; &lt;p&gt;{{ intro_two }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 其中最后一个else属性的值取决于第一个if “show_intro_one” 的值,即$params[$if_value]的值.那如何才能实现if-else正确的匹配呢, 答案就是: 栈. 在我们实现括号匹配, if-else匹配得各种匹配问题中, 栈是一个非常好的思路. 我们第一步需要在dom树同一深度给予不同栈, 因为if-else的匹配只会发生在同级元素直接, 而不会发生在父子元素之间. 第二步自然是每遇到一个if就把值放入对应栈的栈顶. 第三步在遇到else时, 从栈顶取出一个值, 它的反值即为else的值 foreach ($domNode-&gt;childNodes as $item) { // 1. 第一步 $if_stack = []; // ... if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\")) { $if_result = $params[$if_value] ?? false; // 第二步 array_push($if_stack, $if_result); // ... } if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $item-&gt;hasAttribute(\"p-else\")) { // 第三步 $if_result = array_pop($if_stack); if (!$if_result) { $item-&gt;removeAttribute(\"p-else\"); } else { array_push($elementsToRemove, $item); } }} 6. for语法实现&lt;div p-for=\"(value, idx) in items\"&gt; &lt;p&gt;{{ value }} - {{ idx }}&lt;/p&gt; &lt;p&gt;{{ value }}&lt;/p&gt;&lt;/div&gt; for的语法实现思路很简单, 把含有属性p-for属性的元素所有子节点按照遍历的数组循环赋值即可. 其中稍有难度的就是$params中的值传递问题, 或者说$params值的作用域问题, 如果恰好$params中也有个字段叫value或者idx, 但很明显在for的子节点中,value和idx应该是局部作用域, 他们需要在每次循环开始赋予新值, 并在整个循环结束后被销毁. 所以我们让一个新值$for_runtime_params等于外部$params参数, 并在循环中继续递归调用遍历函数 if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $for_value = $item-&gt;getAttribute(\"p-for\")) { preg_match(\"/\\((.*?), (.*?)\\) in (.*)/\", $for_value, $matches); [, $value, $index, $items] = $matches; foreach ($params[$items] as $k =&gt; $v) { $for_runtime_params = $params; $for_runtime_params[$value] = $v; $for_runtime_params[$index] = $k; foreach ($item-&gt;childNodes as $el) { $e = $el-&gt;cloneNode(true); if ($e-&gt;hasChildNodes()) { traversingtDomNode($e, $for_runtime_params); } } }} 注意: 和删除节点一样, 我们在遍历的过程中也不能插入新节点, 他会导致获取的子节点永远为空. 所以也和删除一样单纯记录最后统一插入即可 7. 后记本文实现肯定还有诸多细节未考虑, 但是给大家提供一个不错的思路. 对于未来可以尝试继续实现v-class语法, slot功能, components功能, 都是相当不错的 更详细的实现可以可以查看我的github: cs-render 同时也欢迎在我的博客-showthink阅读更多其他文章 也可以关注我的微博@不会凉的凉凉与我交流","link":"/2018/11/11/dom_template_render/"},{"title":"使用golang写一个redis-cli","text":"0. redis通信协议redis的客户端(redis-cli)和服务端(redis-server)的通信是建立在tcp连接之上， 两者之间数据传输的编码解码方式就是所谓的redis通信协议。所以，只要我们的redis-cli实现了这个协议的解析和编码，那么我们就可以完成所有的redis操作。 redis 协议设计的非常易读，也易于实现，关于具体的redis通信协议请参考：通信协议（protocol）。后面我们在实现这个协议的过程中也会简单重复介绍一下具体实现 1. 建立tcp连接redis客户端和服务端的通信是建立tcp连接之上，所以第一步自然是先建立连接 package mainimport ( \"flag\" \"log\" \"net\")var host stringvar port stringfunc init() { flag.StringVar(&amp;host, \"h\", \"localhost\", \"hsot\") flag.StringVar(&amp;port, \"p\", \"6379\", \"port\")}func main() { flag.Parse() tcpAddr := &amp;net.TCPAddr{IP: net.ParseIP(host), Port: port} conn, err := net.DialTCP(\"tcp\", nil, tcpAddr) if err != nil { log.Println(err) } defer conn.Close() // to be continue} 后续我们发送和接受数据便都可以使用conn.Read()和conn.Write()来进行了 2. 发送请求发送请求第一个第一个字节是”*”，中间是包含命令本身的参数个数，后面跟着”\\r\\n” 。之后使用”$”加参数字节数量并使用”\\r\\n”结尾，然后紧跟参数内容同时也使用”\\r\\n”结尾。如执行 SET key liangwt 客户端发送的请求为”*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$7\\r\\nliangwt\\r\\n” 注意： 命令本身也作为协议的其中一个参数来发送 \\r\\n 对应byte的十进制为 13 10 我们可以使用telnet测试下 wentao@bj:～/github.com/liangwt/redis-cli$ telnet 127.0.0.1 6379Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is '^]'.*3$3SET$3key$7liangwt+OK 先暂时忽略服务端的回复，通过telnet我们可以看出请求协议非常简单，所以对于请求协议的实现不做过多的介绍了，直接放代码(如下使用基于字符串拼接，只是为了更直观的演示，效率并不高，实际代码中我们使用bytes.Buffer来实现) func MultiBulkMarshal(args ...string) string { var s string s = \"*\" s += strconv.Itoa(len(args)) s += \"\\r\\n\" // 命令所有参数 for _, v := range args { s += \"$\" s += strconv.Itoa(len(v)) s += \"\\r\\n\" s += v s += \"\\r\\n\" } return s} 在实现了对命令和参数进行编码之后，我们便可以通过conn.Write()把数据推送到服务端 func main() { // .... req := MultiBulkMarshal(\"SET\", \"key\", \"liangwt\") _, err = conn.Write([]byte(req)) if err != nil { log.Fatal(err) } // to be continue} 3. 获取回复我们首先实现通过tcp获取服务端返回值，就是上面提到过的conn.Read()。 func main() { // .... p := make([]byte, 1024) _, err = conn.Read(p) if err != nil { log.Fatal(err) } // to be continue} 4. 解析回复我们拿到p之后我们就可以解析返回值了，redis服务端的回复是分为几种情况的 状态回复 错误回复 整数回复 批量回复 多条批量回复 我们把前四种单独看作一组，因为他们都是单一类型的返回值 我们把最后的多条批量回复看成单独的一组，因为它是包含前面几种类型的混合类型。而且你可以发现它和我们的请求协议是一样的 也正是基于以上的考虑我们创建两个函数来分别解析单一类型和混合类型，这样在解析混合类型中的某一类型时就只需要调用单一类型解析的函数即可 在解析具体协议前我们先实现一个是读取到\\r\\n为止的函数 func ReadLine(p []byte) ([]byte, error) { for i := 0; i &lt; len(p); i++ { if p[i] == '\\r' { if p[i+1] != '\\n' { return []byte{}, errors.New(\"format error\") } return p[0:i], nil } } return []byte{}, errors.New(\"format error\")} 第一种状态回复：状态回复是一段以 “+” 开始， “\\r\\n” 结尾的单行字符串。如 SET 命令成功的返回值：”+OK\\r\\n” 所以我们判断第一个字符是否等于 ‘+’ 如果相等，则读取到\\r\\n func SingleUnMarshal(p []byte) ([]byte, int, error) { var ( result []byte err error length int ) switch p[0] { case '+': result, err = ReadLine(p[1:]) length = len(result) + 3 } return result, length, err} 注：我们在返回实际回复内容的同时也返回了整个回复的长度，方便后面解析多条批量回复时定位下一次的解析位置 第二种错误回复：错误回复的第一个字节是 “-“， “\\r\\n” 结尾的单行字符串。如执行 SET key缺少参数时返回值：”-ERR wrong number of arguments for ‘set’ command\\r\\n” 错误回复和状态回复非常相似，解析方式也是一样到。所以我们只需添加一个case即可 func SingleUnMarshal(p []byte) ([]byte, int, error) { var ( result []byte err error length int ) switch p[0] { case '+', '-': result, err = ReadLine(p[1:]) length = len(result) + 3 } return result, length, err} 第三种整数回复：整数回复的第一个字节是”:”，中间是字符串表示的整数，”\\r\\n” 结尾的单行字符串。如执行LLEN mylist命令时返回 “:10\\r\\n” 整数回复也和上面两种是一样的，只不过返回的是字符串表示的十进制整数 func SingleUnMarshal(p []byte) ([]byte, int, error) { var ( result []byte err error length int ) switch p[0] { case '+', '-', ':': result, err = ReadLine(p[1:]) length = len(result) + 3 } return result, length, err} 第四种批量回复：批量回复的第一个字节为 “$”，接下来是字符串表示的整数，它表示实际回复的长度，之后跟着一个 “\\r\\n”，再后面跟着的是实际回复数据，最末尾是另一个 “\\r\\n”。如GET key 命令的返回值：”$7\\r\\nliangwt\\r\\n” 所以批量回复解析的实现： 读取第一行得到实际回复的长度 把字符串类型的长度转换成对应十进制整数 从第二行开始位置往下读对应长度 但是对于某些不存在的key，批量回复会将特殊值 -1 用作回复的长度值, 此时我们不需要继续往下读取实际回复。例如GET NOT_EXIST_KEY 返回值：”$-1”, 所以我们需要对此特殊情况判断，让函数返回一个空对象(nil)而不是空值(“”) func SingleUnMarshal(p []byte) ([]byte, int, error) { // .... case '$': n, err := ReadLine(p[1:]) if err != nil { return []byte{}, 0, err } l, err := strconv.Atoi(string(n)) if err != nil { return []byte{}, 0, err } if l == -1 { return nil, 0, nil } // +3 的原因 $ \\r \\n 三个字符 result = p[len(n)+3 : len(n)+3+l] length = len(n) + 5 + l } return result, length, err} 思考：为什么redis要使用提前告知字节数，然后往下读取指定长度的方式，而不是直接读取第二行到\\r\\n为止？ 答案很明显：此方式可以让redis读取返回值时不受具体的返回内容影响，在按行读取的情况下，无论使用任何分割符都有可能导致redis在解析具体内容时把内容中的分割符当作时结尾，导致解析错误。 思考一下这种情况：我们SET key &quot;liang\\r\\nwt&quot; ，那么当我们GET key时，服务端返回值为”$9\\r\\nliang\\r\\nwt\\r\\n” 完全规避了value中的\\r\\n影响 第五种多条批量回复：多条批量回复是由多个回复组成的数组，它的第一个字节为”*”， 后跟一个字符串表示的整数值， 这个值记录了多条批量回复所包含的回复数量， 再后面是一个”\\r\\n”。如LRANGE mylist 0 -1的返回值：”*3\\r\\n$1\\r\\n3\\r\\n$1\\r\\n2\\r\\n$1\\r\\n1”。 所以多条批量回复解析的实现： 解析第一行数据获得字符串类型的回复数量 把字符串类型的长度转换成对应十进制整数 按照单条回复依次逐个解析，一共解析成上面得到的数量 在这里我们用到了单条解析时返回的字节长度length，通过这个长度我们可以很方便的知道下次单条解析的开始位置为上一次位置+length 在解析多条批量回复时需要注意两点： 第一，多条批量回复也可以是空白的（empty）。例如执行LRANGE NOT_EXIST_KEY 0 -1 服务端返回值”*0\\r\\n”。此时客户端返回的应该空数组[][]byte 第二，多条批量回复也可以是无内容的（null multi bulk reply)。例如执行BLPOP key 1 服务端返回值”*-1\\r\\n”。此时客户端返回的应该是nil func MultiUnMarsh(p []byte) ([][]byte, error) { if p[0] != '*' { return [][]byte{}, errors.New(\"format error\") } n, err := ReadLine(p[1:]) if err != nil { return [][]byte{}, err } l, err := strconv.Atoi(string(n)) if err != nil { return [][]byte{}, err } // 多条批量回复也可以是空白的（empty) if l == 0 { return [][]byte{}, nil } // 无内容的多条批量回复（null multi bulk reply）也是存在的, // 客户端库应该返回一个 null 对象, 而不是一个空数组。 if l == -1 { return nil, nil } result := make([][]byte, l) t := len(n) + 3 for i := 0; i &lt; l; i++ { ret, length, err := SingleUnMarshal(p[t:]) if err != nil { return [][]byte{}, errors.New(\"format error\") } result[i] = ret t += length } return result, nil} 5. 命令行模式一个可用的redis-cli自然是一个交互式的，用户输入指令然后输出返回值。在go中我们可以使用以下代码即可获得一个类似的交互式命令行 func main() { // .... for { fmt.Printf(\"%s:%d&gt;\", host, port) bio := bufio.NewReader(os.Stdin) input, _, err := bio.ReadLine() if err != nil { log.Fatal(err) } fmt.Printf(\"%s\\n\", input) }} 我们运行以上代码就可以实现 localhost:6379&gt;set key liangset key lianglocalhost:6379&gt;get keyget keylocalhost:6379&gt; 结合上我们的redis发送请求和解析请求即可完成整个redis-cli func main() { // .... for { fmt.Printf(\"%s:%d&gt;\", host, port) // 获取输入命令和参数 bio := bufio.NewReader(os.Stdin) input, err := bio.ReadString('\\n') if err != nil { log.Fatal(err) } fields := strings.Fields(input) // 编码发送请求 req := MultiBulkMarshal(fields...) // 发送请求 _, err = conn.Write([]byte(req)) if err != nil { log.Fatal(err) } // 读取返回内容 p := make([]byte, 1024) _, err = conn.Read(p) if err != nil { log.Fatal(err) } // 解析返回内容 if p[0] == '*' { result, err := MultiUnMarsh(p) } else { result, _, err := SingleUnMarshal(p) } } // ....} 6. 总结到目前为止我们的cli程序已经全部完成，但其实还有很多不完美地方。但核心的redis协议解析已经完成，使用这个解析我们能完成任何的cli与服务器之间的交互 更详细的redis-cli实现可以参考我的github：A Simaple redis cli - Rclient 也可以关注我的微博@不会凉的凉凉与我交流","link":"/2018/10/08/redis_cli/"},{"title":"SNAT服务搭建：IP分享","text":"准备首先使用vmware创建两台虚拟机，这里全部选用了centos7系统， 同时虚拟机的网络链接使用桥接，桥接的方式使每一个虚拟机在网络内和独立的机器表现一致 SNAT服务器的网络参数设置创建虚拟网卡，并设置私有IP地址查看SNAT服务器的ip地址 ip address show 显示 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:21:73:be brd ff:ff:ff:ff:ff:ff inet 192.168.199.134/24 brd 192.168.199.255 scope global noprefixroute dynamic ens33 valid_lft 35442sec preferred_lft 35442sec inet6 fe80::59eb:3929:5162:3f61/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::957e:fa38:5e70:d608/64 scope link noprefixroute valid_lft forever preferred_lft forever 说明已经通过DHCP获取到了局域网IP，这个网段为192.168.199.0/24，所绑定的网卡为ens33 我们就把这个网段当作公网ip（只能是当作了。。。） 我们创建一个虚拟网卡ens33:0并绑定192.168.100.201/24这个网段当作私有ip ip add address 192.168.100.201/24 broadcast + dev ens33:0 此时查看ip地址 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:21:73:be brd ff:ff:ff:ff:ff:ff inet 192.168.199.134/24 brd 192.168.199.255 scope global noprefixroute dynamic ens33 valid_lft 35442sec preferred_lft 35442sec inet 192.168.100.201/24 brd 192.168.100.255 scope global ens33:0 valid_lft forever preferred_lft forever inet6 fe80::59eb:3929:5162:3f61/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::957e:fa38:5e70:d608/64 scope link noprefixroute valid_lft forever preferred_lft forever 已经多了inet 192.168.100.201/24 brd 192.168.100.255 scope global ens33:0这一条记录了 此时SNAT的网络设置如图 设置iptables规则第一步设置INPUT链为接受 iptables -A INPUT -i ens33:0 -j ACCEPT 然后开启转发功能 echo \"1\" &gt; /proc/sys/net/ipv4/ip_forward 加入NAT table数据包伪装 iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -o ens33 -j MASQUERADE 此时的iptables 策略为 &gt; iptables-save# Generated by iptables-save v1.4.21 on Wed Mar 20 01:12:40 2019*nat:PREROUTING ACCEPT [200:74558]:INPUT ACCEPT [126:69331]:OUTPUT ACCEPT [36:2704]:POSTROUTING ACCEPT [36:2704]-A POSTROUTING -s 192.168.100.0/24 -o ens33 -j MASQUERADECOMMIT# Completed on Wed Mar 20 01:12:40 2019# Generated by iptables-save v1.4.21 on Wed Mar 20 01:12:40 2019*filter:INPUT ACCEPT [343:167886]:FORWARD ACCEPT [1896:4166748]:OUTPUT ACCEPT [43:4105]COMMIT# Completed on Wed Mar 20 01:12:40 2019 经过上面的设置服务器已经具有了SNAT的功能 PC-ONE网络参数设置设置IP地址首先查看ip地址 ip address add 192.168.100.201/24 broadcast + dev ens33:0 显示 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:e7:a6:ec brd ff:ff:ff:ff:ff:ff inet 192.168.199.176/24 brd 192.168.199.255 scope global noprefixroute dynamic ens33 valid_lft 43106sec preferred_lft 43106sec inet6 fe80::59eb:3929:5162:3f61/64 scope link noprefixroute valid_lft forever preferred_lft forever 说明已经通过DHCP获取到了局域网IP，这个网段为192.168.199.0/24，所绑定的网卡为ens33 我们不用这个，删除所分配的ip ip address del 192.168.199.176/24 dev ens33 现在我们重新设置一个不同网段的ip，同时绑定到ens33的网卡上，下面命令重的broadcast + 表示全播地址自动计算 ip address add 192.168.100.200/24 broadcast + dev ens33 设置PC-ONE路由查看当前路由 &gt; ip route show192.168.100.0/24 dev ens33 proto kernel scope link src 192.168.100.200 此时ping 我们模拟的公网服务器192.168.199.116肯定是不会通的因为既不在同一个网段，又没有设置网关 我们添加一个默认的网关，网关的地址就是我们SNAT服务器的私有ip，这个路由信息必须在SNAT服务器设置完私有ip之后才能添加，因为本机与网关之间必须是联通的状态 &gt; ip route add default via 192.168.100.201 dev ens33&gt; ip route show default via 192.168.199.1 dev ens33 proto dhcp metric 100192.168.100.0/24 dev ens33 proto kernel scope link src 192.168.100.200 设置完成后整个链路就变成了下图 于是PC-ONE就隐藏在了SNAT服务器之后，对外只能看到SNAT服务器的地址，SANT充当着防火墙的作用 数据传递链路分析这次我们在模拟的公网服务器192.168.199.116上监听一个端口 nc -l 8000 然后在PC-ONE上连接此端口肯定是可以联通的并互相通信的 从PC-ONE到公网服务器 PC发出的数据报头来源为192.168.100.200，传送到SNAT服务器 SNAT服务器内部接口192.168.100.200接受数据后，分析发现目标地址并非本机，所以把数据转到public ip处 SNAT服务器通过iptables的POSTROUTING链将数据包的报头来源伪装成SANT的public ip，并将两个不同来源192.168.100.200和public ip记录带内存 所以在公共网络上看到这个数据的来源都是来自SNAT的public ip 从公网服务器到PC-ONE 公网服务器会将响应数据传送给Public IP的主机，即SNAT主机； 当 Linux NAT 服务器收到来自公网服务器的回应封包后，会分析该封包的序号，并比对刚刚记录到内存当中的数据， 由于发现该封包为后端主机之前传送出去的，因此在 NAT Prerouting 链中，会将目标 IP 修改成为后端主机，亦即那部 192.168.100.200，然后发现目标已经不是本机 (public IP)， 所以开始透过路由分析封包流向； 封包会传送到 192.168.100.201 这个内部接口，然后再传送到最终目标 192.168.100.200 机器上去！","link":"/2019/05/11/snat_build/"},{"title":"字符串化中双重宏定义的用法","text":"字符串化运算符 (#)使用# 你可以定义一个字符串常量的宏。当一个宏参数使用#开头，预处理器会把文本原有当内容当作是一个字符串常量替换。 例如： #define WARN_IF(EXP) \\do { if (EXP) \\ fprintf (stderr, \"Warning: \" #EXP \"\\n\"); } \\while (0)WARN_IF (x == 0);==&gt; do { if (x == 0) fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); } while (0); EXP在if中被按照普通的方式替换， 在fprintf中按照字符串的方式被替换，但是，如果说我们 #define x XXX 在这种情况下，if 条件中的x会被正确的展开。而fprintf中，因为使用字符串化符号，所以x依旧是”x==0” 所以最后结果会变成 #define x XXX#define WARN_IF(EXP) \\do { if (EXP) \\ fprintf (stderr, \"Warning: \" #EXP \"\\n\"); } \\while (0)WARN_IF (x == 0);==&gt; do { if (x == 0) fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); } while (0); ==&gt; do { if (XXX == 0) fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); } while (0); 双重宏如果你想字符串化一个宏的结果值，你必须定义双重宏 例如： #define xstr(s) str(s)#define str(s) #s#define foo 4str (foo) ==&gt; \"foo\" xstr (foo) ==&gt; xstr (4) ==&gt; str (4) ==&gt; \"4\" 上面例子中，第一个str(foo)因为是符合字符串化条件，所以foo的宏并没有被替换 第二个例子xstr (foo)由于不符合条件所以进行foo的宏被替换为了4而后str(4)被处理为”4” 转义字符串其实并不是简单的在代码两边加上双引号，预处理器会对字符串中的反斜线()和引号（” 和 ‘)进行转义，使之成为一个有效的c语言字符串 例如： #define x (p = 'foo\\n')#define y (p = \"foo\\n\")x ==&gt; \"p = \\\"foo\\\\n\\\"y ==&gt; \"p = \\'foo\\n\\' 空白开头和结尾的空白都会被忽略对于字符串中间的空白只会有一个对于注释在字符串化之前都已经被空白替换，所以不会在字符串化的结果中出现 字符在宏中没有办法实现字符","link":"/2018/10/08/stringification/"},{"title":"malloc中的brk和mmap.md","text":"内存分配的原理–molloc/brk/mmap http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/ 内存分配的原理__进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。 如何查看进程发生缺页中断的次数？用ps -o majflt,minflt -C program命令查看。 majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。这两个数值表示一个进程自启动以来所发生的缺页中断的次数。 发生缺页中断后，执行了那些操作？ 当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：1、检查要访问的虚拟地址是否合法 2、查找/分配一个物理页 3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干） 4、建立映射关系（虚拟地址到物理地址） 重新执行发生缺页中断的那条指令 如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。 内存分配的原理从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。 1、brk是将数据段(.data)的最高地址指针_edata往高地址推； 2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。 下面以一个例子来说明内存分配的原理：情况一、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图： 1、进程启动的时候，其（虚拟）内存空间的初始布局如图1-(1)所示。 其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。 _edata指针（glibc里面定义）指向数据段的最高地址。 2、进程调用A=malloc(30K)以后，内存空间如图1-(2)： malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。 你可能会问：只要把_edata+30K就完成内存分配了？ 事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。 3、进程调用B=malloc(40K)以后，内存空间如图1-(3)。 情况二、malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图： 4、进程调用C=malloc(200K)以后，内存空间如图2-(4)： 默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。 这样子做主要是因为::brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。 5、进程调用D=malloc(100K)以后，内存空间如图2-(5)； 6、进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放如图2-(6)。 7、进程调用free(B)以后，如图3-(7)所示： B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？ 当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。 8、进程调用free(D)以后，如图3-(8)所示： B和D连接起来，变成一块140K的空闲内存。 9、默认情况下： 当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图3-(9)所示。 mmap 样例#include&lt;sys/mman.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main(){ int i,j,k,l; char *mp; mp = (char*)mmap(NULL, 1000000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); *mp = 'A'; munmap(mp, 1000000); return 0;} #include&lt;sys/mman.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main(){ int i,j,k,l; int fd; char *mp; fd = open(\"/tmp/mmap\", O_CREAT|O_RDWR, 00777); lseek(fd, 100, SEEK_SET); write(fd, \"\", 1); mp = malloc(1000000); mp = (char*)mmap(NULL, 100, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); i = *mp; *mp = 'A'; munmap(mp, 100); return 0;}","link":"/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/malloc%E4%B8%AD%E7%9A%84brk%E5%92%8Cmmap/"}],"tags":[{"name":"node","slug":"node","link":"/tags/node/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"BFC","slug":"BFC","link":"/tags/BFC/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"Template","slug":"Template","link":"/tags/Template/"},{"name":"Render","slug":"Render","link":"/tags/Render/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"redis-cli","slug":"redis-cli","link":"/tags/redis-cli/"},{"name":"protocol","slug":"protocol","link":"/tags/protocol/"},{"name":"iptables","slug":"iptables","link":"/tags/iptables/"},{"name":"SNAT","slug":"SNAT","link":"/tags/SNAT/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"macro","slug":"macro","link":"/tags/macro/"},{"name":"stringification","slug":"stringification","link":"/tags/stringification/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"FRONTEND","slug":"FRONTEND","link":"/categories/FRONTEND/"},{"name":"BACKEND","slug":"BACKEND","link":"/categories/BACKEND/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}