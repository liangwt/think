{"pages":[],"posts":[{"title":"深入了解bufio 包","text":"最近用golang写了一个处理文件的脚本，由于其中涉及到了文件读写，开始使用golang中的 io 包，后来发现golang 中提供了一个bufio的包，使用这个包可以大幅提高文件读写的效率，于是在网上搜索同样的文件读写为什么bufio 要比io 的读写更快速呢？根据网上的资料和阅读源码，以下来详细解释下bufio的高效如何实现的。 bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。 以上为官方包的介绍，在其中我们能了解到的信息如下： bufio 是通过缓冲来提高效率 简单的说就是，把文件读取进缓冲（内存）之后再读取的时候就可以避免文件系统的io 从而提高速度。同理，在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。看完以上解释有人可能会表示困惑了，直接把 内容-&gt;文件 和 内容-&gt;缓冲-&gt;文件相比， 缓冲区好像没有起到作用嘛。其实缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。下面会详细解释 bufio 封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象 io.Reader或io.Writer 接口实现read() 和 write() 方法，对于实现这个接口的对象都是可以使用这两个方法的 bufio 包实现原理 bufio 源码分析 Reader对象 bufio.Reader 是bufio中对io.Reader 的封装 123456789// Reader implements buffering for an io.Reader object.type Reader struct { buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions err error lastByte int lastRuneSize int} bufio.Read(p []byte) 相当于读取大小len(p)的内容，思路如下： 当缓存区有内容的时，将缓存区内容全部填入p并清空缓存区 当缓存区没有内容的时候且len(p)&gt;len(buf),即要读取的内容比缓存区还要大，直接去文件读取即可 当缓存区没有内容的时候且len(p)&lt;len(buf),即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满（此时缓存区有剩余内容） 以后再次读取时缓存区有内容，将缓存区内容全部填入p并清空缓存区（此时和情况1一样） 以下是源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Read reads data into p.// It returns the number of bytes read into p.// The bytes are taken from at most one Read on the underlying Reader,// hence n may be less than len(p).// At EOF, the count will be zero and err will be io.EOF.func (b *Reader) Read(p []byte) (n int, err error) { n = len(p) if n == 0 { return 0, b.readErr() } if b.r == b.w { if b.err != nil { return 0, b.readErr() } if len(p) &gt;= len(b.buf) { // Large read, empty buffer. // Read directly into p to avoid copy. n, b.err = b.rd.Read(p) if n &lt; 0 { panic(errNegativeRead) } if n &gt; 0 { b.lastByte = int(p[n-1]) b.lastRuneSize = -1 } return n, b.readErr() } // One read. // Do not use b.fill, which will loop. b.r = 0 b.w = 0 n, b.err = b.rd.Read(b.buf) if n &lt; 0 { panic(errNegativeRead) } if n == 0 { return 0, b.readErr() } b.w += n } // copy as much as we can n = copy(p, b.buf[b.r:b.w]) b.r += n b.lastByte = int(b.buf[b.r-1]) b.lastRuneSize = -1 return n, nil} 说明： reader内部通过维护一个r, w 即读入和写入的位置索引来判断是否缓存区内容被全部读出 Writer对象 bufio.Writer 是bufio中对io.Writer 的封装 1234567// Writer implements buffering for an io.Writer object.type Writer struct { err error buf []byte n int wr io.Writer} bufio.Write(p []byte) 的思路如下 判断buf中可用容量是否可以放下 p 如果能放下，直接把p拼接到buf后面，即把内容放到缓冲区 如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可 如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区 判断p的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区 如果p的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤2一样）则把p的剩余内容直接写入文件 以下是源码 123456789101112131415161718192021222324252627// Write writes the contents of p into the buffer.// It returns the number of bytes written.// If nn &lt; len(p), it also returns an error explaining// why the write is short.func (b *Writer) Write(p []byte) (nn int, err error) { for len(p) &gt; b.Available() &amp;&amp; b.err == nil { var n int if b.Buffered() == 0 { // Large write, empty buffer. // Write directly from p to avoid copy. n, b.err = b.wr.Write(p) } else { n = copy(b.buf[b.n:], p) b.n += n b.flush() } nn += n p = p[n:] } if b.err != nil { return nn, b.err } n := copy(b.buf[b.n:], p) b.n += n nn += n return nn, nil} 说明： b.wr 存储的是一个io.writer对象，实现了Write()的接口，所以可以使用b.wr.Write(p) 将p的内容写入文件 b.flush() 会将缓存区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件 b.Available() 为buf可用容量，等于len(buf) - n 下图解释的是其中一种情况，即缓存区有内容，剩余p大于缓存区","link":"/2018/03/08/bufio/"},{"title":"理解BFC特性","text":"在解释BFC之前，先说一下文档流。 我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。 常见的FC有BFC、IFC，还有GFC和FFC。BFC是block formatting context，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域 触发 BFC只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC 特性及应用 同一个 BFC 下外边距会发生折叠 BFC 可以包含浮动的元素（清除浮动） 我相信大家经常会遇到一个容器里有浮动元素，但是这个容器的高度却是0的场景，如下图： 看下面的例子： 1234&lt;div class=\"container\"&gt; &lt;div&gt;Sibling&lt;/div&gt; &lt;div&gt;Sibling&lt;/div&gt;&lt;/div&gt; 123456789.container { background-color: green;} .container div { float: left; background-color: lightgreen; margin: 10px;} 结果： 在上边的情形中，container是不会有高度的，因为它包含了浮动元素。通常我们解决这个问题的办法是利用一个伪元素去实现clear fix，但是现在我们有了更好的解决办法，即利用BFC，因为它够容纳浮动元素的。 我们现在让container形成BFC规则，结果如下： 12345678910.container { overflow: hidden; /* creates block formatting context */ background-color: green;} .container div { float: left; background-color: lightgreen; margin: 10px;} 结果： BFC 可以阻止元素被浮动元素覆盖 参考链接 理解CSS中的BFC(块级可视化上下文) 深入理解BFC 布局概念 关于CSS-BFC深入理解","link":"/2018/05/25/CSS_BFC/"},{"title":"commonJS 中的模块导出与导入","text":"模块导出方式123456789101112//module.jsvar x = 5var foo = function (value){ return x + value}//以下等价module.exports.x = xmodule.exports.foo = fooexports.x = xexports.foo = foo 模块导入方式123example = require(\"./module.js\")console.log(example.x) // 5consile.log(example.foo(1)) // 6 说明：exports 是对module.exports的引用，即 exports=module.exports module.exports初始的时候置为{},exports也指向这个空对象。 require方能看到的只有module.exports这个对象，看不到exports对象，所以使用 exports = foo 是导不出去导，因为此时exports 已经和module.exports 没有关系了 https://www.zhihu.com/question/26621212","link":"/2018/05/07/commonJS_export_and_import/"},{"title":"建站踩坑指南","text":"本站搭建在腾讯云实例上，使用了docker构建了node、hexo、redis、mysql、php-fpm实例 其中大部分容器镜像为手动构建，并使用了docker-compose进行了容器编排 本文记录在搭建站点过程中的坑与解决方案 本站docker环境git地址：https://gitee.com/liangwt_admin/docker_env本站博文git地址：https://gitee.com/liangwt_admin/hexo_blog git将空文件夹加入到版本控制git只对文件进行版本控制，当一个文件夹为空或者 将文件夹 /logs/* 写入.gitignore 中，会导致这个文件夹并不会被纳入版本控制但是为了保持文件结构我们需要保留空文件夹所以可以在空文件夹下创建一个.gitkeep 或 .keep 文件，并在.gitignore 加入!.gitkeep这样就会把空文件夹加入到git中 腾讯安全组策略腾讯云控制台可以设置安全组策略，其中一个默认策略并没有加入6973（redis默认）端口 即使没有开放对应端口，tcp的syn 请求依旧能够打入机器，但是并不能建立连接，推测原因为腾讯云安全组策略为虚拟包过滤防火墙 12345678910root@VM-0-10-ubuntu:/data# netstat -catnp | grep :6379tcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnettcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnettcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnettcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp 0 1 172.21.0.10:42518 140.143.163.206:6379 SYN_SENT 22480/telnet netstats 只显示tcp612345678root@VM-0-10-ubuntu:/data# netstat -anptActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 981/sshdtcp 0 344 172.21.0.10:22 218.30.113.39:61883 ESTABLISHED 29283/sshd: ubuntutcp6 0 0 :::6379 :::* LISTEN 19806/docker-proxytcp6 0 0 :::80 :::* LISTEN 19795/docker-proxytcp6 0 0 :::443 :::* LISTEN 19742/docker-proxy 发现redis只监听了tcp6端口，最后发现如下结论：netstat 只是很真实的显示监听的端口而已，但是需要注意 ipv6 实际上在 Linux 上也支持 ipv4。 参考 http://www.cnblogs.com/wlzjdm/p/8684202.html","link":"/2018/04/25/build_site/"},{"title":"几种对象创建方式和原型链","text":"除了直接用对象字面量{ … }创建一个对象外，还可以使用new 构造函数funciton name(){…} 来创建对象 注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this 工厂模式1234567891011function createPerson1(name, job) { var o = new Object() o.name = name o.job = job o.sayName = function () { console.log(this.name) } return o}var person1 = new createPerson1('Jiang', 'student')var person2 = new createPerson1('X', 'Doctor') 缺点:不能知道一个对象的类型 1console.log(typeof person1) // object 构造函数模式12345678910function person2(name, job) { this.name = name this.job = job this.sayName = function () { console.log(this.name) }}var person3 = new person2('Jiang', 'student')var person4 = new person2('X', 'doctor') 缺点Jiang和X各自的name不同，这是对的，否则我们无法区分谁是谁了。 Jiang和X各自的sayName是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！ 使用构造函数创建对象，每个方法都要在每个实例上重新创建一次，即sayName()在每一个对象中都存在 原型模式原型链背景知识 因为JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 1person1.prototype--&gt;Person.prototype--&gt;Object.prototype--&gt;null 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 123456789function Person3() {}Person3.prototype.name = 'Jiang'Person3.prototype.job = 'student'person3.prototype.sayName = function () { console.log(this.name)}person5 = new Person3() 更简单的原型模式写法1234567891011function Person4() {}Person4.prototype = { name: 'Jiang', job: 'student', sayName: function () { console.log(this.name) }}person6 = new Person4() 优化 Person.prototypeconstructor属性 Person.prototype 等于了一个对象字面量所以会导致.constructor不再指向Person4 如果需要这个属性可以手动添加 12345678Person4.prototype = { constructor: Person4, name: 'Jiang', job: 'student', sayName: function () { console.log(this.name) }} Person.prototypeconstructor枚举性 此时的constuctor属性是可以枚举的，默认的constructor是不可以枚举的，所以也可以单独设置 1234Object.defineProperty(Person4.prototype,'constructor', { enumerable: false, value:Person4}) sayName()只在第一次初始化的时候创建，之后就不会被创建了 原形链缺点： 原型的所有属性都是被所有实例所共享的 对于不同实例函数确实是需要共享的，但是对于基本属性是不需要共享的 一个实例改变某个饮用类型的属性值，其他实例也会被改变 组合使用构造函数模式和原型模式最广泛使用，使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用 1234567891011function Person5(name, job){ //属性 this.name = name this.job = job}Person5.prototype.sayName = function(){ console.log(this.name)}var person9 = new Person5('Jiang','student')var person10 = new Person5('X','doctor') 动态原型模式通过在初始化的时候判断某方法是否存在来决定是否有添加到对象原型中 12345678910111213function Person6(name, job){ this.name = name this.job = job if(this.sayName !== 'function'){ Person6.prototype.sayName = function(){ console.log(this.name) } }}var person11 = new Person6('Jiang', 'student')var person12 = new Person6('x', 'doctor') 参考 JavaScript创建对象的七种方式 一篇文章看懂_proto_和prototype的关系及区别 创建对象","link":"/2018/06/03/create_object/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/06/26/hello-world/"},{"title":"使用DOM解析来实现PHP模版引擎","text":"0. 前言: 传统模版语法的不利之处目前市面上有很多PHP的模版引擎, 如smarty、blade等. 其中大部分都是基于正则表达式将其中的模版语法转换成PHP代码, 并进行缓存. 模版代码所经历的过程如下: 1template -&gt; php -&gt; html 使用正则替换或者直接使用PHP原生有什么问题呢? 以下我们以blade为例来看一些具体例子: 123456789101112131415&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;div class=\"items\" &gt; @if (count($records) === 1) &lt;p&gt;我有一个记录！&lt;/p&gt; @elseif (count($records) &gt; 1) &lt;p&gt;我有多个记录！&lt;/p&gt; @else &lt;p&gt;我没有任何记录！&lt;/p&gt; @endif &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 问题一: 编辑器格式化和语法高亮的问题如上, 我们面临的第一个问题是html和blade语法混杂在一起. 在阅读逻辑上, 我们需要来回的在blade和html之间做转化.当然, 当你熟悉了blade的语法并熟练掌握这个能力的时候, 这种转化并不会对你的阅读构成障碍.但是, 对于编辑器来说, 如果不使用合适的插件, 无论是代码高亮还是自动格式化都会产生意想不到结果 问题二: html中渲染class等属性其实以上还不是最令人眼花缭乱的,在我有限的工作经历中, 使用PHP渲染html中的class或者其他属性时, 经常会看到如下令人恐怖的代码 123456789101112&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;ul class=\"items\" &gt; &lt;li &lt;?= $cur==1 ? 'class=\"active\"' : ''?&gt;&gt;NO.1&lt;/li&gt; &lt;li &lt;?= $cur==2 ? 'class=\"active\"' : ''?&gt;&gt;NO.2&lt;/li&gt; &lt;li &lt;?= $cur==3 ? 'class=\"active\"' : ''?&gt;&gt;NO.3&lt;/li&gt; &lt;li &lt;?= $cur==4 ? 'class=\"active\"' : ''?&gt;&gt;NO.4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上还不是最恐怖的, 当有的人既不使用&lt;?= ?&gt;又不使用三元运算时…简直不可想象. 问题三: 公共模版中代码代码的不完整对于大部分网页的头部和尾部,我们单独抽离出来以供复用. 对于blade这种支持类似插槽的模版引擎,情况并不算太糟, 单对于不支持类似特性的模版引擎, 如下的代码也是非常常见 1234567#./header.phtml 头文件&lt;html&gt;&lt;body&gt; &lt;div class=\"nav\"&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; 1234567#./bottom.phtml 尾文件 &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如上的问题在于什么呢, 每个部分模版都不是标签闭合的,每一部分并不完整. 在独立模版存在非常多的情况下, 正确的让html标签闭合也成为开发负担之一. 好了, 说完了这么多问题, 我们来想一想是否有解决的办法. 要知道以前前端js代码合并也是基于正则, 但是新的三大框架都是基于dom解析来实现. 那如果说, 我们在写php渲染页面的时候也可以和Vue一样, 使用类似如下的语法, 是不是就能解决以上的问题呢? 当然本文只是给大家提供一个最基本的思路, 和最基础的实现, 仅供娱乐和思路拓展吧. 1234567891011121314151617181920&lt;!-- ./tpl.html --&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;div class=\"title\"&gt; &lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt; &lt;/div&gt; &lt;div p-else&gt; &lt;p&gt;{{ vistor }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div p-for=\"(value, idx) in items\"&gt; &lt;p&gt;{{ value }} - {{ idx }}&lt;/p&gt; &lt;p&gt;{{ value }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112$params = [ \"is_author\" =&gt; true, \"author\" =&gt; \"liangwt\", \"vistor\" =&gt; \"Welcome\", \"items\" =&gt; [ \"A\", \"B\", \"C\", ],];csRender(\"./tpl.html\", $params); 1234567891011121314151617181920212223&lt;!-- out --&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;div class=\"title\"&gt; &lt;div&gt; &lt;p&gt;liangwt&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Welcome&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;A - 0&lt;/p&gt; &lt;p&gt;A&lt;/p&gt; &lt;p&gt;B - 1&lt;/p&gt; &lt;p&gt;B&lt;/p&gt; &lt;p&gt;C - 2&lt;/p&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1. DOM基本知识 D: Document 代表里文档 O: Object 代表了对象 M: Model 代表了模型 DOM把整个文档表示为一棵树, 确切的说是一个家谱树. 家谱树中我们使用 parent(父)、child(子)、sibling(兄弟)来描述成员之间的关系. 对于一个普通的如下的xml来说 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;bookstore&gt; &lt;book category=\"children\"&gt; &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category=\"cooking\"&gt; &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category=\"web\"&gt; &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;book category=\"web\"&gt; &lt;title lang=\"en\"&gt;XQuery Kick Start&lt;/title&gt; &lt;author&gt;James McGovern&lt;/author&gt; &lt;author&gt;Per Bothner&lt;/author&gt; &lt;author&gt;Kurt Cagle&lt;/author&gt; &lt;author&gt;James Linn&lt;/author&gt; &lt;author&gt;Vaidyanathan Nagarajan&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;49.99&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 我们可以生成如下的dom树结构 示例来源于知乎 2. PHP中DomDocument的使用PHP中原生提供了xml文档解析的拓展, 它使用起来非常简单. 网上资料大多介绍基于此拓展的封装包, 因此这里稍微详细介绍下. (1). DOM中的基类节点: The DOMNode class前面介绍dom树的时候说过, 文档是由不同类型的节点构成的集合, 所以DomDocument中绝大多数的类都继承于此. 它的类属性除了描述了自身名称($nodeName)、值($nodeValue)、类型($nodeType)等, 还描述了其父节点($parentNode)、子节点($childNodes)、同级节点($previousSibling、$nextSibling)等. 它的类方法除了包括对子节点的插入(appendChild())、替换(replaceChild())、 移除(removeChild())之外,还有诸多用于判断自身属性的函数. 作为任何类型的节点基类我们需要重点关注它的每一个属性和方法,参考官方文档. (2). 整个文档: DOMDocument extends DOMNodeDOMDocument继承自DOMNode, 它代表了整个文档, 也是整个文档树的根结点. 其中继承自基类的属性$nodeType是XML_DOCUMENT_NODE(9) 我们通常使用它的load*()来创建dom树,和save*()系列方法将dom转换成文本 我们的代码也是如此开头和结束 1234567function csRender(string $tpl, array $params){ $dom = new DomDocument(\"1.0\", \"UTF-8\"); $dom-&gt;loadHTMLFile($tpl); // ... echo $dom-&gt;saveHTML();} (3). 元素节点 DOMElement extends DOMNodeDOMElement继承自DOMNode, 它代表了 之类的标签, 是构成dom结构的基本节点.其中标签的名字就是节点的属性tagName, 它的$nodeType是XML_ELEMENT_NODE = 1 元素可以包含其他的元素, 元素节点中也包含了其他类型的节点. 我们可以使用getAttributeNode() 或者getAttribute() 来获取元素节点的属性或者属性名,使用getElementsByTagName(string $name)获取元素包含的标签名$name为的节点.以及使用remove*()和set*()函数来删除和修改指定属性 我们在实现上面p-if的时候需要进行判断if条件是否成立,并在之后删除掉这个属性 123456if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\") { if ($if_result) { $item-&gt;removeAttribute(\"p-if\"); }} (4). 属性节点 DOMAttr extends DOMNodeDOMAttr继承自DOMNode, 它代表了标签class=&quot;one&quot;之类的属性, 如上面所讲对元素节点调用getAttributeNode()即可获取此元素的属性节点. 属性节点的nodeType是XML_ATTRIBUTE_NODE=2 (5). 文本节点 DOMText extends DOMCharacterDataDOMText继承自DOMCharacterData, DOMCharacterData也是继承自DOMNode. 在dom中它代表了元素节点包含的文本.其中nodeValue属性就是文本的内容. 文本节点的nodeType 是XML_TEXT_NODE = 3 除此之外需要知道的是, 文本节点单总是被包含在元素节点中, 文本节点的父节点是元素节点. 我们通过$elementNode-&gt;childNodes即可获取(如果有文本节点的话), 此函数返回的是 DOMNodeList 类型,它代表节点集合, 并实现了Traversable接口 我们在实现mustache语法的时候需要判断元素的文本节点中是否有 {{ }} 包裹的变量 123456if ($item-&gt;nodeType == XML_TEXT_NODE) { $str = preg_replace_callback('/\\{\\{(.*?)\\}\\}/', function ($matches) use ($params) { // ...处理逻辑 }, $item-&gt;nodeValue); $item-&gt;nodeValue = $str;} (6). 节点遍历以上就是最常用的几种节点类型了, 我们下面讲一讲如何进行节点遍历.我们需要基于遍历去实现树中节点判断, 然后进行树操作 我们在上面介绍了如何加载一个html文档,其中获取的变量$dom也是dom树的根结点 1234567function csRender(string $tpl, array $params){ $dom = new DomDocument(\"1.0\", \"UTF-8\"); $dom-&gt;loadHTMLFile($tpl); traversingtDomNode($dom, $params); echo $dom-&gt;saveHTML();} 拥有一个节点之后如何遍历它的子节点呢, 我们获取其$domNode-&gt;childNodes子属性进行遍历即可 12345function traversingtDomNode($dom, $params){ foreach ($domNode-&gt;childNodes as $item) { //... }} 在遍历每一个节点过程中, 可以通过判断nodeType来对不同类型节点进行操作. 同时如果此节点依旧有子节点, 我们继续把节点放入此函数进行递归调用 1234567891011121314151617function traversingtDomNode($dom, $params){ foreach ($domNode-&gt;childNodes as $item) { if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\")) { // ... } if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $item-&gt;hasAttribute(\"p-else\")) { // ... } if ($item-&gt;hasChildNodes()) { traversingtDomNode($item, $params); } }} 3. mustache语法实现 {{ key }} 语法实现很简单, 我们只要通过正则拿到 {{ key }} 中的key值, 然后把连着 {{ }} 一起替换成$params[$key]即可 12345678// ... if ($item-&gt;nodeType == XML_TEXT_NODE) { $str = preg_replace_callback('/\\{\\{(.*?)\\}\\}/', function ($matches) use ($params) { return $params[trim($matches[1])]; }, $item-&gt;nodeValue); $item-&gt;nodeValue = $str; }// ... 4. if语法实现123&lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt;&lt;/div&gt; if语法实现也很简单, 我们通过$if_value =$item-&gt;getAttribute(&quot;p-if&quot;)获取属性值, 并通过判断$params[$if_value]`的值, 如果成立,则删掉属性, 展示此元素节点. 如果不成立则删掉此节点. 12345678910// ... if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\")) { $if_result = $params[$if_value] ?? false; if ($if_result) { $item-&gt;removeAttribute(\"p-if\"); } else { array_push($elementsToRemove, $item); } }// ... 注意这里面有个小坑: 参考文档中的一条评论:在遍历中移除节点,会导致dom树重构,遍历终止. 所以我们采取将要移除的节点单独记录的方式,在循环结束后统一移除 12345678$elementsToRemove = [];foreach ($domNode-&gt;childNodes as $item) { // ..}foreach ($elementsToRemove as $item) { $item-&gt;parentNode-&gt;removeChild($item);} 5. eles语法实现12345678910&lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt; &lt;div p-if=\"show_intro\"&gt; &lt;p&gt;{{ intro }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p p-else&gt; {{ vistor }} &lt;/p&gt;&lt;/div&gt; else 的实现会用到很有意思的技巧, 因为else的真值并不取决于它自身, 而是取决于和它配对的if的值. 注意!是和它配对的if值, 如果你想当然的认为是else之前的那个if值可就错咯. 我们看下面这个例子: 12345678910111213141516&lt;div p-if=\"is_author\"&gt; &lt;p&gt;{{ author }}&lt;/p&gt; &lt;div p-if=\"show_intro_one\"&gt; &lt;p&gt;{{ intro_one }}&lt;/p&gt; &lt;/div&gt; &lt;div p-if=\"show_comment_one\"&gt; &lt;p&gt;{{ comment_one }}&lt;/p&gt; &lt;/div&gt; &lt;div p-else&gt; &lt;p&gt;{{ comment_two }}&lt;/p&gt; &lt;/div&gt; &lt;div p-else&gt; &lt;p&gt;{{ intro_two }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 其中最后一个else属性的值取决于第一个if “show_intro_one” 的值,即$params[$if_value]的值.那如何才能实现if-else正确的匹配呢, 答案就是: 栈. 在我们实现括号匹配, if-else匹配得各种匹配问题中, 栈是一个非常好的思路. 我们第一步需要在dom树同一深度给予不同栈, 因为if-else的匹配只会发生在同级元素直接, 而不会发生在父子元素之间. 第二步自然是每遇到一个if就把值放入对应栈的栈顶. 第三步在遇到else时, 从栈顶取出一个值, 它的反值即为else的值 12345678910111213141516171819202122foreach ($domNode-&gt;childNodes as $item) { // 1. 第一步 $if_stack = []; // ... if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $if_value = $item-&gt;getAttribute(\"p-if\")) { $if_result = $params[$if_value] ?? false; // 第二步 array_push($if_stack, $if_result); // ... } if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $item-&gt;hasAttribute(\"p-else\")) { // 第三步 $if_result = array_pop($if_stack); if (!$if_result) { $item-&gt;removeAttribute(\"p-else\"); } else { array_push($elementsToRemove, $item); } }} 6. for语法实现1234&lt;div p-for=\"(value, idx) in items\"&gt; &lt;p&gt;{{ value }} - {{ idx }}&lt;/p&gt; &lt;p&gt;{{ value }}&lt;/p&gt;&lt;/div&gt; for的语法实现思路很简单, 把含有属性p-for属性的元素所有子节点按照遍历的数组循环赋值即可. 其中稍有难度的就是$params中的值传递问题, 或者说$params值的作用域问题, 如果恰好$params中也有个字段叫value或者idx, 但很明显在for的子节点中,value和idx应该是局部作用域, 他们需要在每次循环开始赋予新值, 并在整个循环结束后被销毁. 所以我们让一个新值$for_runtime_params等于外部$params参数, 并在循环中继续递归调用遍历函数 1234567891011121314151617if ($item-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; $for_value = $item-&gt;getAttribute(\"p-for\")) { preg_match(\"/\\((.*?), (.*?)\\) in (.*)/\", $for_value, $matches); [, $value, $index, $items] = $matches; foreach ($params[$items] as $k =&gt; $v) { $for_runtime_params = $params; $for_runtime_params[$value] = $v; $for_runtime_params[$index] = $k; foreach ($item-&gt;childNodes as $el) { $e = $el-&gt;cloneNode(true); if ($e-&gt;hasChildNodes()) { traversingtDomNode($e, $for_runtime_params); } } }} 注意: 和删除节点一样, 我们在遍历的过程中也不能插入新节点, 他会导致获取的子节点永远为空. 所以也和删除一样单纯记录最后统一插入即可 7. 后记本文实现肯定还有诸多细节未考虑, 但是给大家提供一个不错的思路. 对于未来可以尝试继续实现v-class语法, slot功能, components功能, 都是相当不错的 更详细的实现可以可以查看我的github: cs-render 同时也欢迎在我的博客-showthink阅读更多其他文章 也可以关注我的微博@不会凉的凉凉与我交流","link":"/2018/11/11/dom_template_render/"},{"title":"深入了解net&#x2F;http","text":"http包提供了HTTP客户端和服务端的实现。 最简单Web服务1234567891011121314package mainimport ( \"fmt\" \"log\" \"net/http\")func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Println(\"hello\") }) log.Fatal(http.ListenAndServe(\"localhost:8000\", nil))} 我们先分析下面这个函数 func ListenAndServe(addr string, handler Handler) error addr 参数很明显就是监听的host和端口 handler 参数是一个满足Handler 接口的对象 我们首先来了解下Handler类型其定义如下 123type Handler interface { ServeHTTP(ResponseWriter, *Request)} 也就是说凡是实现了ServeHTTP(ResponseWriter, *Request) 方法的类型都是满足Handler接口的，所以我们可以用下面的方式来实现一个web服务 （上面的说法并不严谨，我会在最后讲述使用http.HandlerFunc()进行类型转换来实现满足Handler接口的方法） 12345678910111213141516171819202122import ( \"fmt\" \"log\" \"net/http\")type myHandler struct {}func (h myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { switch r.URL.Path { case \"/\": fmt.Println(\"hello\") default: w.WriteHeader(http.StatusNotFound) fmt.Fprintf(w, \"not found: %s\\n\", r.URL) }}func main() { handler := myHandler{} log.Fatal(http.ListenAndServe(\"localhost:8000\", handler))} 可能有人注意到了我们在最开始写的，最简单的web服务中的http.ListenAndServe(&quot;localhost:8000&quot;, nil)我们向第二个参数传递的是nil，并不满足http.Handler接口，这个问题我们留到下面去解答 http.ServeMux ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。 上面的例子中myHandler.ServeHTTP()实际上既实现了路由分配又实现了逻辑处理。在大多数情况下，我们更希望不同的路由交由不同的方法来处理，所以http包中引入了ServeMux类型来帮助我们实现路由分配 用法123456789101112type myHandler struct {}func (h myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \"hello world\")}func main() { handler := myHandler{} mux := http.NewServeMux() mux.Handle(\"/\", handler) log.Fatal(http.ListenAndServe(\"localhost:8000\", mux))} ServeMux的结构12345678910type ServeMux struct { mu sync.RWMutex //锁，由于请求涉及到并发处理，因此这里需要一个锁机制 m map[string]muxEntry // 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式 hosts bool // 是否在任意的规则中带有host信息}type muxEntry struct { explicit bool // 是否精确匹配 h Handler // 这个路由表达式对应哪个handler pattern string //匹配字符串} 可以注意到muxEntry中的h的类型为实现Handler接口结构的对象 路由解析实现思路通过ServeMux可以看到实际的路由规则记录在ServeMux.m 中，这个属性是一个map[string]muxEntry 类型，string记录都是路由，muxEntry里包含实际的handler 通过http.ListenAndServe(&quot;localhost:8000&quot;, mux)很容易想到ServeMux实现了也实现了Handler接口(拥有ServerHTTP()方法) 所以实现路由解析的原理为 ListenAndServe() 调用ServeMux中的ServerHTTP() ServeMux中的ServerHTTP()方法会根据路由去map[string]muxEntry中找到对应的muxEntry，然后调用muxEntry中的 h.ServerHTTP() 源码入下 1234567891011121314151617181920212223242526272829303132333435func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) { if r.RequestURI == \"*\" { w.Header().Set(\"Connection\", \"close\") w.WriteHeader(StatusBadRequest) return } h, _ := mux.Handler(r) h.ServeHTTP(w, r)}func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) { if r.Method != \"CONNECT\" { if p := cleanPath(r.URL.Path); p != r.URL.Path { _, pattern = mux.handler(r.Host, p) return RedirectHandler(p, StatusMovedPermanently), pattern } } return mux.handler(r.Host, r.URL.Path)}func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) { mux.mu.RLock() defer mux.mu.RUnlock() // Host-specific pattern takes precedence over generic ones if mux.hosts { h, pattern = mux.match(host + path) } if h == nil { h, pattern = mux.match(path) } if h == nil { h, pattern = NotFoundHandler(), \"\" } return} 添加handler通过上面路由解析的原理可以了解：据用户请求的URL和路由器里面存储的map去匹配，当匹配到之后返回存储的handler，调用这个handler的ServeHTTP接口就可以执行到相应的函数了。 而将URL和handler 添加到map中则需要使用func (mux *ServeMux) Handle(pattern string, handler Handler) 看上面用法也可以很容易理解 mux.Handle(“/“, handler) Handle() 函数将URL:”/“ 添加到了map的键，将对应的handler 添加到了muxEntry结构中 http.HandlerFunc()还记得上面的说法：凡是实现了ServeHTTP(ResponseWriter, *Request) 方法的类型都是满足Handler接口的。但实际开发中我们会发现大部分handler 并没有实现ServeHTTP() 的函数，而是如下的一种方式 12345678910111213141516type myHandler struct {}func (h myHandler) index(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \"hello world\")}func (h myHandler) News(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \"news one\")}func main() { h := myHandler{} mux := http.NewServeMux() mux.Handle(\"/\", http.HandlerFunc(h.index)) mux.Handle(\"/news\", http.HandlerFunc(h.News)) log.Fatal(http.ListenAndServe(\"localhost:8000\", mux))} http.HandlerFunc(h.index)在这里并不是函数调用，而是强制的类型转换 123456type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP calls f(w, r).func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r)} 即我们调用了HandlerFunc(f),强制类型转换f成为HandlerFunc类型，这样f就拥有了ServeHTTP方法。 mux.HandleFunc()因为像上面http.HandlerFunc() 方式是非常普遍的，所以下面两个是等价的 12mux.HandleFunc(\"/\", h.index)mux.Handle(\"/news\", http.HandlerFunc(h.News)) http.HandleFunc()注意和上面的http.HandlerFunc()进行区分，前者是实现了Handler接口的类型，可使用强制类型转换http.HandlerFunc(f) 让f拥有ServeHTTP方法。 后者是为默认的ServeMux：DefaultServeMux注册路由和handler http.ListenAndServe(&quot;localhost:8000&quot;, nil)中第二参数为nil时，http.Serve()便使用DefaultServeMuxz作为处理的handler Go代码的执行流程通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。首先调用Http.HandleFunc按顺序做了几件事： 调用了DefaultServeMux的HandleFunc 调用了DefaultServeMux的Handle 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则 其次调用http.ListenAndServe(&quot;:9090&quot;, nil)按顺序做了几件事情： 实例化Server 调用Server的ListenAndServe() 调用net.Listen(“tcp”, addr)监听端口 启动一个for循环，在循环体中Accept请求 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve() 读取每个请求的内容w, err := c.readRequest() 判断handler是否为空，如果没有设置handler（这个例子就没有设置handler），handler就设置为DefaultServeMux 调用handler的ServeHttp 在这个例子中，下面就进入到DefaultServeMux.ServeHttp 根据request选择handler，并且进入到这个handler的ServeHTTPmux.handler(r).ServeHTTP(w, r) 选择handler： 判断是否有路由能满足这个request（循环遍历ServerMux的muxEntry） 如果有路由满足，调用这个路由handler的ServeHttp 如果没有路由满足，调用NotFoundHandler的ServeHttp 参考资料 《go web 编程》 - 3.4 Go的http包详解 golang http.handler接口详解 http://blog.csdn.net/secretx/article/details/51556648","link":"/2018/03/08/net_http/"},{"title":"窗口和iframe间的通讯postMessage","text":"问题 窗口间跨域数据传输 iframe与窗口间的跨域数据传输 html5引入的message的API可以更方便、有效、安全的解决这些难题。postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 但postMessage()不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据 前提postMessage是用于两个窗口（iframe）之间交换数据的，如果我们同时打开着百度和谷歌两个页面，是不是说这两者之间就可以通信了？No，no，no，事实并非如此，就算百度和谷歌俩页面有通信的意愿也不行。 两个窗口能通信的前提是: 一个窗口以iframe的形式存在于另一个窗口 或者一个窗口是从另一个窗口通过window.open()或者超链接的形式打开的（同样可以用window.opener获取源窗口) 换句话说，你要交换数据，必须能获取目标窗口(target window)的引用，不然两个窗口之间毫无联系，想通信也无能为力。 使用方式1otherWindow.postMessage(message, targetOrigin, [transfer]); 说明： otherWindow是对接收方窗口的引用，一般可以是以下几种方式： 12345window.frames[0].postMessagedocument.getElementsByTagName('iframe')[0].contentWindow.postMessagewindow.opener.postMessageevent.source.postMessagewindow.open //返回的引用 message：顾名思义就是发送的数据内容，支持字符串、数字、json等几乎所有形式的数据 origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“ 接受信息接收方需要接受信息只需要监听message事件即可 1234// 监听有没有数据发送过来window.addEventListener('message', function(e) { console.log(e);}); 当然也可以使用onmessage，不过兼容性不好 123window.onmessage = function(e){ console.log(e);} message Event的几个属性 data：顾名思义，是传递来的message source：发送消息的window对象 可以用于数据回传即e.source.postmessage('get','*') origin：发送消息窗口的源（协议+主机+端口号） 可以用于校验messgae是否来自允许域即 123if(e.origin != \"http://www.foo.com:80\"){ return false} 也可用于回传到消息来源方 1e.source.postmessage('get',e.origin) 示例代码 window &lt;-&gt; iframe 1234567891011121314&lt;!-- http://localhost:81/fish/index.html --&gt;&lt;script type=\"text/javascript\"&gt; // 页面加载完后才能获取dom节点（iframe） window.onload = function(){ // 向目标源发送数据 document.getElementsByTagName('iframe')[0].contentWindow.postMessage({\"age\":10}, 'http://localhost:8080'); }; // 监听有没有数据发送过来 window.addEventListener('message', function(e) { console.log(e); });&lt;/script&gt;&lt;iframe src=\"http://localhost:8080/index.html\"&gt;&lt;/iframe&gt; 12345678910111213&lt;!-- http://localhost:8080/index.html --&gt;&lt;script type=\"text/javascript\"&gt; // 监听有没有数据发送过来 window.addEventListener('message', function(e){ // 判断数据发送方是否是可靠的地址 if(e.origin !== 'http://localhost:81') return; // 打印数据格式 console.log(e); // 回发数据 e.source.postMessage('hello world', e.origin); }, false);&lt;/script&gt; window &lt;-&gt; window 1234567891011&lt;!-- http://localhost:81/fish/index.html --&gt;&lt;script type=\"text/javascript\"&gt; // 打开一个新的窗口 var popup = window.open('http://localhost:8080/index.html'); //新窗口必须加载完毕后才能收到messge事件，所以需要等待，也可设计成新窗口加载完毕后通知父窗口 setTimeout(function() { // 当前窗口向目标源传数据 popup.postMessage({\"age\":10}, 'http://localhost:8080'); }, 1000);&lt;/script&gt; 12345678&lt;!-- http://localhost:8080/index.html --&gt;&lt;script type=\"text/javascript\"&gt; // 设置监听，如果有数据传过来，则打印 window.addEventListener('message', function(e) { console.log(e); console.log(e.source === window.opener); // true });&lt;/script&gt;","link":"/2018/06/01/postmessage/"},{"title":"go函数值传递深入理解","text":"通过传递指针改变原有值的例子123456789101112131415161718192021222324package mainimport ( \"fmt\")type Person struct { name string age int}func main() { A := Person{ name: \"liang\", age: 18, } Handler(&amp;A) fmt.Println(A) //{wen 18}}func Handler(p *Person) { p.name = \"wen\"} 我们知道函数或者方法通过传递指针，可以改变传入变量的值 如上，通过把A的指针传入Handler(p *Person)中，我们把A的name改成了”wen” 但是看下面这个例子： 通过传递指针不能改变原有值的例子123456789101112131415161718192021222324252627package mainimport ( \"fmt\")type Person struct { name string age int}func main() { A := Person{ name: \"liang\", age: 18, } Handler(&amp;A) fmt.Println(A) //{liang 18}}func Handler(p *Person) { p = &amp;Person{ name: \"wen\", age: 19, }} 我们再次把A的地址传入Handler()中，并为其赋了一个新的person值，结果很明显，A的值并没有被改写，依旧是原来的值 原因：函数的值传递在golang里函数或者方法的参数永远是值传递，这句话正确的理解应该是： 如果是普通类型的参数，那么传递就是普通参数的副本 如果是引用类型的参数，那么传递的是参数指针地址的副本 理解这个值传递的关键，就在上面加粗的副本两个字，对于指针参数也是如此 所以第一个例子中，我们传入参数A的地址，Handler() 的参数复制A的地址，获得了A地址的另一份拷贝，无论是复制的新的指针还是原有指针它们都指向了A 如图，很明显我们可以通过p来改写A的属性，因为p 和 &amp;A指向同一个变量 而第二个例子中，我们将Handler()中对p指向了另外一个地址，所以只是对p赋了新值，并没有对&amp;A产生影响 验证以上说法我们来写代码验证下以上说法 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\")type Person struct { name string age int}func main() { A := Person{ name: \"liang\", age: 18, } //0xc42000a080 fmt.Printf(\"%p\\n\", &amp;A) Handler(&amp;A) //0xc42000a080 fmt.Printf(\"%p\\n\", &amp;A)}func Handler(p *Person) { //0xc42000a080 fmt.Printf(\"%p\\n\", p) p = &amp;Person{ name: \"wen\", age: 19, } //0xc42000a0a0 fmt.Printf(\"%p\\n\", p)} 可以看出来&amp;A地址0xc42000a080 在调用Handler()前后是没有变化对，Handler()中p变量最开始也是接收到这个0xc42000a080值，但是随后对赋值，让p有了新值，所以也就失去对原有变量对引用 联想: commonJS中模块导出的exportscommonJS使用 1234567891011121314module.exports.foo = foo``` 是可以导出模块的，但是使用```jsexports = foo``` 是不行的，原因其实是因为```jsvar module = { exports: {} };var exports = module.exports; exports变量其实也是一个对module.exports的引用，重新赋值会导致exports失去原有变量的引用 而模块最后return出去的其实module.exports,所以对exports新赋值是不会被导出去的 CommonJS 模块导出方式123456789101112//module.jsvar x = 5var foo = function (value){ return x + value}//以下等价module.exports.x = xmodule.exports.foo = fooexports.x = xexports.foo = foo CommonJS 模块导入方式123example = require(\"./module.js\")console.log(example.x) // 5consile.log(example.foo(1)) // 6 说明：exports 是对module.exports的引用，即 exports=module.exports module.exports初始的时候置为{},exports也指向这个空对象。 require方能看到的只有module.exports这个对象，看不到exports对象，所以使用 exports = foo 是导不出去导，因为此时exports 已经和module.exports 没有关系了 https://www.zhihu.com/question/26621212","link":"/2018/07/01/pass_by_pointer/"},{"title":"使用golang写一个redis-cli","text":"0. redis通信协议redis的客户端(redis-cli)和服务端(redis-server)的通信是建立在tcp连接之上， 两者之间数据传输的编码解码方式就是所谓的redis通信协议。所以，只要我们的redis-cli实现了这个协议的解析和编码，那么我们就可以完成所有的redis操作。 redis 协议设计的非常易读，也易于实现，关于具体的redis通信协议请参考：通信协议（protocol）。后面我们在实现这个协议的过程中也会简单重复介绍一下具体实现 1. 建立tcp连接redis客户端和服务端的通信是建立tcp连接之上，所以第一步自然是先建立连接 12345678910111213141516171819202122232425262728package mainimport ( \"flag\" \"log\" \"net\")var host stringvar port stringfunc init() { flag.StringVar(&amp;host, \"h\", \"localhost\", \"hsot\") flag.StringVar(&amp;port, \"p\", \"6379\", \"port\")}func main() { flag.Parse() tcpAddr := &amp;net.TCPAddr{IP: net.ParseIP(host), Port: port} conn, err := net.DialTCP(\"tcp\", nil, tcpAddr) if err != nil { log.Println(err) } defer conn.Close() // to be continue} 后续我们发送和接受数据便都可以使用conn.Read()和conn.Write()来进行了 2. 发送请求发送请求第一个第一个字节是”*”，中间是包含命令本身的参数个数，后面跟着”\\r\\n” 。之后使用”$”加参数字节数量并使用”\\r\\n”结尾，然后紧跟参数内容同时也使用”\\r\\n”结尾。如执行 SET key liangwt 客户端发送的请求为”*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$7\\r\\nliangwt\\r\\n” 注意： 命令本身也作为协议的其中一个参数来发送 \\r\\n 对应byte的十进制为 13 10 我们可以使用telnet测试下 123456789101112wentao@bj:～/github.com/liangwt/redis-cli$ telnet 127.0.0.1 6379Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is '^]'.*3$3SET$3key$7liangwt+OK 先暂时忽略服务端的回复，通过telnet我们可以看出请求协议非常简单，所以对于请求协议的实现不做过多的介绍了，直接放代码(如下使用基于字符串拼接，只是为了更直观的演示，效率并不高，实际代码中我们使用bytes.Buffer来实现) 1234567891011121314151617func MultiBulkMarshal(args ...string) string { var s string s = \"*\" s += strconv.Itoa(len(args)) s += \"\\r\\n\" // 命令所有参数 for _, v := range args { s += \"$\" s += strconv.Itoa(len(v)) s += \"\\r\\n\" s += v s += \"\\r\\n\" } return s} 在实现了对命令和参数进行编码之后，我们便可以通过conn.Write()把数据推送到服务端 123456789func main() { // .... req := MultiBulkMarshal(\"SET\", \"key\", \"liangwt\") _, err = conn.Write([]byte(req)) if err != nil { log.Fatal(err) } // to be continue} 3. 获取回复我们首先实现通过tcp获取服务端返回值，就是上面提到过的conn.Read()。 123456789func main() { // .... p := make([]byte, 1024) _, err = conn.Read(p) if err != nil { log.Fatal(err) } // to be continue} 4. 解析回复我们拿到p之后我们就可以解析返回值了，redis服务端的回复是分为几种情况的 状态回复 错误回复 整数回复 批量回复 多条批量回复 我们把前四种单独看作一组，因为他们都是单一类型的返回值 我们把最后的多条批量回复看成单独的一组，因为它是包含前面几种类型的混合类型。而且你可以发现它和我们的请求协议是一样的 也正是基于以上的考虑我们创建两个函数来分别解析单一类型和混合类型，这样在解析混合类型中的某一类型时就只需要调用单一类型解析的函数即可 在解析具体协议前我们先实现一个是读取到\\r\\n为止的函数 1234567891011func ReadLine(p []byte) ([]byte, error) { for i := 0; i &lt; len(p); i++ { if p[i] == '\\r' { if p[i+1] != '\\n' { return []byte{}, errors.New(\"format error\") } return p[0:i], nil } } return []byte{}, errors.New(\"format error\")} 第一种状态回复：状态回复是一段以 “+” 开始， “\\r\\n” 结尾的单行字符串。如 SET 命令成功的返回值：”+OK\\r\\n” 所以我们判断第一个字符是否等于 ‘+’ 如果相等，则读取到\\r\\n 123456789101112131415func SingleUnMarshal(p []byte) ([]byte, int, error) { var ( result []byte err error length int ) switch p[0] { case '+': result, err = ReadLine(p[1:]) length = len(result) + 3 } return result, length, err} 注：我们在返回实际回复内容的同时也返回了整个回复的长度，方便后面解析多条批量回复时定位下一次的解析位置 第二种错误回复：错误回复的第一个字节是 “-“， “\\r\\n” 结尾的单行字符串。如执行 SET key缺少参数时返回值：”-ERR wrong number of arguments for ‘set’ command\\r\\n” 错误回复和状态回复非常相似，解析方式也是一样到。所以我们只需添加一个case即可 12345678910111213func SingleUnMarshal(p []byte) ([]byte, int, error) { var ( result []byte err error length int ) switch p[0] { case '+', '-': result, err = ReadLine(p[1:]) length = len(result) + 3 } return result, length, err} 第三种整数回复：整数回复的第一个字节是”:”，中间是字符串表示的整数，”\\r\\n” 结尾的单行字符串。如执行LLEN mylist命令时返回 “:10\\r\\n” 整数回复也和上面两种是一样的，只不过返回的是字符串表示的十进制整数 12345678910111213func SingleUnMarshal(p []byte) ([]byte, int, error) { var ( result []byte err error length int ) switch p[0] { case '+', '-', ':': result, err = ReadLine(p[1:]) length = len(result) + 3 } return result, length, err} 第四种批量回复：批量回复的第一个字节为 “$”，接下来是字符串表示的整数，它表示实际回复的长度，之后跟着一个 “\\r\\n”，再后面跟着的是实际回复数据，最末尾是另一个 “\\r\\n”。如GET key 命令的返回值：”$7\\r\\nliangwt\\r\\n” 所以批量回复解析的实现： 读取第一行得到实际回复的长度 把字符串类型的长度转换成对应十进制整数 从第二行开始位置往下读对应长度 但是对于某些不存在的key，批量回复会将特殊值 -1 用作回复的长度值, 此时我们不需要继续往下读取实际回复。例如GET NOT_EXIST_KEY 返回值：”$-1”, 所以我们需要对此特殊情况判断，让函数返回一个空对象(nil)而不是空值(“”) 1234567891011121314151617181920func SingleUnMarshal(p []byte) ([]byte, int, error) { // .... case '$': n, err := ReadLine(p[1:]) if err != nil { return []byte{}, 0, err } l, err := strconv.Atoi(string(n)) if err != nil { return []byte{}, 0, err } if l == -1 { return nil, 0, nil } // +3 的原因 $ \\r \\n 三个字符 result = p[len(n)+3 : len(n)+3+l] length = len(n) + 5 + l } return result, length, err} 思考：为什么redis要使用提前告知字节数，然后往下读取指定长度的方式，而不是直接读取第二行到\\r\\n为止？ 答案很明显：此方式可以让redis读取返回值时不受具体的返回内容影响，在按行读取的情况下，无论使用任何分割符都有可能导致redis在解析具体内容时把内容中的分割符当作时结尾，导致解析错误。 思考一下这种情况：我们SET key &quot;liang\\r\\nwt&quot; ，那么当我们GET key时，服务端返回值为”$9\\r\\nliang\\r\\nwt\\r\\n” 完全规避了value中的\\r\\n影响 第五种多条批量回复：多条批量回复是由多个回复组成的数组，它的第一个字节为”*”， 后跟一个字符串表示的整数值， 这个值记录了多条批量回复所包含的回复数量， 再后面是一个”\\r\\n”。如LRANGE mylist 0 -1的返回值：”*3\\r\\n$1\\r\\n3\\r\\n$1\\r\\n2\\r\\n$1\\r\\n1”。 所以多条批量回复解析的实现： 解析第一行数据获得字符串类型的回复数量 把字符串类型的长度转换成对应十进制整数 按照单条回复依次逐个解析，一共解析成上面得到的数量 在这里我们用到了单条解析时返回的字节长度length，通过这个长度我们可以很方便的知道下次单条解析的开始位置为上一次位置+length 在解析多条批量回复时需要注意两点： 第一，多条批量回复也可以是空白的（empty）。例如执行LRANGE NOT_EXIST_KEY 0 -1 服务端返回值”*0\\r\\n”。此时客户端返回的应该空数组[][]byte 第二，多条批量回复也可以是无内容的（null multi bulk reply)。例如执行BLPOP key 1 服务端返回值”*-1\\r\\n”。此时客户端返回的应该是nil 1234567891011121314151617181920212223242526272829303132333435func MultiUnMarsh(p []byte) ([][]byte, error) { if p[0] != '*' { return [][]byte{}, errors.New(\"format error\") } n, err := ReadLine(p[1:]) if err != nil { return [][]byte{}, err } l, err := strconv.Atoi(string(n)) if err != nil { return [][]byte{}, err } // 多条批量回复也可以是空白的（empty) if l == 0 { return [][]byte{}, nil } // 无内容的多条批量回复（null multi bulk reply）也是存在的, // 客户端库应该返回一个 null 对象, 而不是一个空数组。 if l == -1 { return nil, nil } result := make([][]byte, l) t := len(n) + 3 for i := 0; i &lt; l; i++ { ret, length, err := SingleUnMarshal(p[t:]) if err != nil { return [][]byte{}, errors.New(\"format error\") } result[i] = ret t += length } return result, nil} 5. 命令行模式一个可用的redis-cli自然是一个交互式的，用户输入指令然后输出返回值。在go中我们可以使用以下代码即可获得一个类似的交互式命令行 12345678910111213func main() { // .... for { fmt.Printf(\"%s:%d&gt;\", host, port) bio := bufio.NewReader(os.Stdin) input, _, err := bio.ReadLine() if err != nil { log.Fatal(err) } fmt.Printf(\"%s\\n\", input) }} 我们运行以上代码就可以实现 12345localhost:6379&gt;set key liangset key lianglocalhost:6379&gt;get keyget keylocalhost:6379&gt; 结合上我们的redis发送请求和解析请求即可完成整个redis-cli 123456789101112131415161718192021222324252627282930313233343536373839func main() { // .... for { fmt.Printf(\"%s:%d&gt;\", host, port) // 获取输入命令和参数 bio := bufio.NewReader(os.Stdin) input, err := bio.ReadString('\\n') if err != nil { log.Fatal(err) } fields := strings.Fields(input) // 编码发送请求 req := MultiBulkMarshal(fields...) // 发送请求 _, err = conn.Write([]byte(req)) if err != nil { log.Fatal(err) } // 读取返回内容 p := make([]byte, 1024) _, err = conn.Read(p) if err != nil { log.Fatal(err) } // 解析返回内容 if p[0] == '*' { result, err := MultiUnMarsh(p) } else { result, _, err := SingleUnMarshal(p) } } // ....} 6. 总结到目前为止我们的cli程序已经全部完成，但其实还有很多不完美地方。但核心的redis协议解析已经完成，使用这个解析我们能完成任何的cli与服务器之间的交互 更详细的redis-cli实现可以参考我的github：A Simaple redis cli - Rclient 也可以关注我的微博@不会凉的凉凉与我交流","link":"/2018/10/08/redis_cli/"},{"title":"字符串化中双重宏定义的用法","text":"字符串化运算符 (#)使用# 你可以定义一个字符串常量的宏。当一个宏参数使用#开头，预处理器会把文本原有当内容当作是一个字符串常量替换。 例如： 12345678#define WARN_IF(EXP) \\do { if (EXP) \\ fprintf (stderr, \"Warning: \" #EXP \"\\n\"); } \\while (0)WARN_IF (x == 0);==&gt; do { if (x == 0) fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); } while (0); EXP在if中被按照普通的方式替换， 在fprintf中按照字符串的方式被替换，但是，如果说我们 1#define x XXX 在这种情况下，if 条件中的x会被正确的展开。而fprintf中，因为使用字符串化符号，所以x依旧是”x==0” 所以最后结果会变成 123456789101112#define x XXX#define WARN_IF(EXP) \\do { if (EXP) \\ fprintf (stderr, \"Warning: \" #EXP \"\\n\"); } \\while (0)WARN_IF (x == 0);==&gt; do { if (x == 0) fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); } while (0); ==&gt; do { if (XXX == 0) fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); } while (0); 双重宏如果你想字符串化一个宏的结果值，你必须定义双重宏 例如： 12345678910#define xstr(s) str(s)#define str(s) #s#define foo 4str (foo) ==&gt; \"foo\" xstr (foo) ==&gt; xstr (4) ==&gt; str (4) ==&gt; \"4\" 上面例子中，第一个str(foo)因为是符合字符串化条件，所以foo的宏并没有被替换 第二个例子xstr (foo)由于不符合条件所以进行foo的宏被替换为了4而后str(4)被处理为”4” 转义字符串其实并不是简单的在代码两边加上双引号，预处理器会对字符串中的反斜线()和引号（” 和 ‘)进行转义，使之成为一个有效的c语言字符串 例如： 123456#define x (p = 'foo\\n')#define y (p = &quot;foo\\n&quot;)x ==&gt; &quot;p = \\&quot;foo\\\\n\\&quot;y ==&gt; &quot;p = \\'foo\\n\\' 空白开头和结尾的空白都会被忽略对于字符串中间的空白只会有一个对于注释在字符串化之前都已经被空白替换，所以不会在字符串化的结果中出现 字符在宏中没有办法实现字符","link":"/2018/10/08/stringification/"},{"title":"SNAT服务搭建：IP分享","text":"准备首先使用vmware创建两台虚拟机，这里全部选用了centos7系统， 同时虚拟机的网络链接使用桥接，桥接的方式使每一个虚拟机在网络内和独立的机器表现一致 SNAT服务器的网络参数设置创建虚拟网卡，并设置私有IP地址查看SNAT服务器的ip地址 1ip address show 显示 12345678910111213141516171819202122231: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:21:73:be brd ff:ff:ff:ff:ff:ff inet 192.168.199.134/24 brd 192.168.199.255 scope global noprefixroute dynamic ens33 valid_lft 35442sec preferred_lft 35442sec inet6 fe80::59eb:3929:5162:3f61/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::957e:fa38:5e70:d608/64 scope link noprefixroute valid_lft forever preferred_lft forever``` 说明已经通过DHCP获取到了局域网IP，这个网段为192.168.199.0/24，所绑定的网卡为ens33&lt;!-- more --&gt;我们就把这个网段当作公网ip（只能是当作了。。。）我们创建一个虚拟网卡ens33:0并绑定192.168.100.201/24这个网段当作私有ip ip add address 192.168.100.201/24 broadcast + dev ens33:0 12此时查看ip地址 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:21:73:be brd ff:ff:ff:ff:ff:ff inet 192.168.199.134/24 brd 192.168.199.255 scope global noprefixroute dynamic ens33 valid_lft 35442sec preferred_lft 35442sec inet 192.168.100.201/24 brd 192.168.100.255 scope global ens33:0 valid_lft forever preferred_lft forever inet6 fe80::59eb:3929:5162:3f61/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::957e:fa38:5e70:d608/64 scope link noprefixroute valid_lft forever preferred_lft forever 12345678910已经多了`inet 192.168.100.201/24 brd 192.168.100.255 scope global ens33:0`这一条记录了此时SNAT的网络设置如图![SNAT服务器](https://tva1.sinaimg.cn/large/b373c093ly1g19mmliexaj212w0jdac0.jpg)#### 设置iptables规则第一步设置INPUT链为接受 iptables -A INPUT -i ens33:0 -j ACCEPT 12然后开启转发功能 echo “1” &gt; /proc/sys/net/ipv4/ip_forward 12加入NAT table数据包伪装 iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -o ens33 -j MASQUERADE 12此时的iptables 策略为 iptables-save Generated by iptables-save v1.4.21 on Wed Mar 20 01:12:40 2019*nat:PREROUTING ACCEPT [200:74558]:INPUT ACCEPT [126:69331]:OUTPUT ACCEPT [36:2704]:POSTROUTING ACCEPT [36:2704]-A POSTROUTING -s 192.168.100.0/24 -o ens33 -j MASQUERADECOMMIT Completed on Wed Mar 20 01:12:40 2019Generated by iptables-save v1.4.21 on Wed Mar 20 01:12:40 2019*filter:INPUT ACCEPT [343:167886]:FORWARD ACCEPT [1896:4166748]:OUTPUT ACCEPT [43:4105]COMMIT Completed on Wed Mar 20 01:12:40 20191234567891011经过上面的设置服务器已经具有了SNAT的功能### PC-ONE网络参数设置#### 设置IP地址首先查看ip地址```ship address add 192.168.100.201/24 broadcast + dev ens33:0 显示 1234567891011121: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:e7:a6:ec brd ff:ff:ff:ff:ff:ff inet 192.168.199.176/24 brd 192.168.199.255 scope global noprefixroute dynamic ens33 valid_lft 43106sec preferred_lft 43106sec inet6 fe80::59eb:3929:5162:3f61/64 scope link noprefixroute valid_lft forever preferred_lft forever 说明已经通过DHCP获取到了局域网IP，这个网段为192.168.199.0/24，所绑定的网卡为ens33 我们不用这个，删除所分配的ip 1ip address del 192.168.199.176/24 dev ens33 现在我们重新设置一个不同网段的ip，同时绑定到ens33的网卡上，下面命令重的broadcast + 表示全播地址自动计算 1ip address add 192.168.100.200/24 broadcast + dev ens33 设置PC-ONE路由查看当前路由 123&gt; ip route show192.168.100.0/24 dev ens33 proto kernel scope link src 192.168.100.200 此时ping 我们模拟的公网服务器192.168.199.116肯定是不会通的因为既不在同一个网段，又没有设置网关 我们添加一个默认的网关，网关的地址就是我们SNAT服务器的私有ip，这个路由信息必须在SNAT服务器设置完私有ip之后才能添加，因为本机与网关之间必须是联通的状态 123456&gt; ip route add default via 192.168.100.201 dev ens33&gt; ip route show default via 192.168.199.1 dev ens33 proto dhcp metric 100192.168.100.0/24 dev ens33 proto kernel scope link src 192.168.100.200 设置完成后整个链路就变成了下图 于是PC-ONE就隐藏在了SNAT服务器之后，对外只能看到SNAT服务器的地址，SANT充当着防火墙的作用 数据传递链路分析这次我们在模拟的公网服务器192.168.199.116上监听一个端口 1nc -l 8000 然后在PC-ONE上连接此端口肯定是可以联通的并互相通信的 从PC-ONE到公网服务器 PC发出的数据报头来源为192.168.100.200，传送到SNAT服务器 SNAT服务器内部接口192.168.100.200接受数据后，分析发现目标地址并非本机，所以把数据转到public ip处 SNAT服务器通过iptables的POSTROUTING链将数据包的报头来源伪装成SANT的public ip，并将两个不同来源192.168.100.200和public ip记录带内存 所以在公共网络上看到这个数据的来源都是来自SNAT的public ip 从公网服务器到PC-ONE 公网服务器会将响应数据传送给Public IP的主机，即SNAT主机； 当 Linux NAT 服务器收到来自公网服务器的回应封包后，会分析该封包的序号，并比对刚刚记录到内存当中的数据， 由于发现该封包为后端主机之前传送出去的，因此在 NAT Prerouting 链中，会将目标 IP 修改成为后端主机，亦即那部 192.168.100.200，然后发现目标已经不是本机 (public IP)， 所以开始透过路由分析封包流向； 封包会传送到 192.168.100.201 这个内部接口，然后再传送到最终目标 192.168.100.200 机器上去！","link":"/2019/05/11/snat_build/"},{"title":"Shell扩展(Shell Expansions)-参数扩展(Shell Parameter Expansion)","text":"从一个脚本开始在php-docker中可以发现一个docker-php-entrypoint.sh脚本，内容如下 123456789#!/bin/shset -e# first arg is `-f` or `--some-option`if [ \"${1#-}\" != \"$1\" ]; then set -- php-fpm \"$@\"fiexec \"$@\" 简单解释一下这个脚本涉及到的几个知识点，并引出本文要介绍的Shell Parameter Expansion概念 特殊变量$@$@ 属于shell脚本中几个特殊参数中的一个，代表了传递给脚本的所有参数，同时还有其他一些特殊变量可以参考文档Special Parameters 我这里列举如下 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数：”$1”, “$2”, “$3”， 每个变量是独立的。 $@ 传递给脚本或函数的所有参数：”$1 $2 $3”，代表 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 注：$* 和 $@ 的区别$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。 但是当它们被双引号(“ “)包含时 &quot;$*&quot; 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数； &quot;$@&quot; 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。 shell，exec与sourcesh使用$ sh script.sh执行脚本时，当前shell是父进程，生成一个子shell进程，在子shell中执行脚本。脚本执行完毕，退出子shell，回到当前shell。 $ ./script.sh与$ sh script.sh等效。 source使用$ source script.sh方式，在当前上下文中执行脚本，不会生成新的进程。脚本执行完毕，回到当前shell。 $ . script.sh与$ source script.sh等效。 exec方式使用exec command方式，会用command进程替换当前shell进程，并且保持PID不变。执行完毕，直接退出，不回到之前的shell环境。 setset 属于shell内置命令，参考文档#Modifying-Shell-Behavior 当单独执行set命令时会显示所有的环境变量和 Shell 函数 直接使用set+prams 可以为当前环境设置参数,例如 1234567$ set a b c$ echo $1a$ echo $2b$ echo $3c set -e在”set -e”之后出现的代码，一旦出现了返回值非零，整个脚本就会立即退出，用于保证代码安全性 set –其实--是一个单独的shell特性，和set无关，它代表了一个命令的选项（options）已经结束，后面的都已经是这个命令的参数了，例如： 1grep -- -v file 如果你想搜索file中的字符串’-v’，直接grep '-v' file或是其他方法都是导致-v被识别为grep的选项，当加入--代表选项已经没有了，-v被理解为第一个参数，file被理解为第二个参数，于是就可以在file搜索’-v’了 对于set -- 也是一样--标志着set的选项已经结束，后面的都是set的参数了。 为什么要这么写呢？很明显是为了防止set后面设置的变量里含有-导致被解释为set自身的选项，如set -- -e这种情况 结论所以最开始的set -- php-fpm &quot;$@&quot;就可以解释为：把当前环境的参数设置成 php-fpm $@ 即 $@ = php-fpm $@ 对于那句if [ &quot;${1#-}&quot; != &quot;$1&quot; ]我们在下面展开讲解，根据注释我们可以知道它判断的是：传入这个脚本的第一个参数是不是-f or --some-option这种类型 所以总结一下： 当我们sh docker-php-entrypoint.sh -F即直接在脚本后面使用-加参数时，实际执行的是php-fpm -F 当我们sh docker-php-entrypoint.sh ls -a即直接在脚本后面直接执行命令时，实际执行的就是传入的命令ls -a 下面进入本文的主题 参数扩展(Shell Parameter Expansion)在shell中可以使用花括号${}包裹参数来防止紧跟在参数后面的字符串被当作参数变量名的一部分，所以最基本的参数展开就是${parameter}。 间接参数扩展${!parameter}其中引用的参数并不是parameter而是parameter的实际的值 12345parameter=&quot;var&quot;var=&quot;hello&quot;echo ${!parameter}hello 空参数处理下面的几种形式如${parameter:-word}是判断parameter为unset或者parameter=NULL来执行后续的扩展操作，即(!isSet(parameter) || parameter==NULL) 当忽略冒号后的结果${parameter:-} ,判断parameter存在且不为NULL，即(isSet(parameter) &amp;&amp; parameter != NULL) 当忽略冒号${parameter-word}则只判断parameter是否存在，也就是parameter可以为NULL，即isSet(parameter) ${parameter:-word} 当parameter未设置或者为空则替换成word 12345678set a b echo ${3:-word} # wordecho ${1:-word} # aecho ${par:-word} # wordpar=cecho ${par:-word} # c ${parameter:=word} 同上。也就是给parameter一个默认参数，所以位置参数和特殊参数不能以这种方式分配。即不能${3:=world} 12345678set a b echo ${3:=word} # -bash: $3: cannot assign in this wayecho ${1:=word} # aecho ${par:=word} # wordpar=cecho ${par:=word} # c ${parameter:?word} 当变量 parameter 未设置或为空，shell 也是可交互时，进行报错并且退出。如果 shell 不可交互，则发生变量替换。 123456789set a b echo ${3:?word} # -bash: 3: wordecho $? # 1 说明错误echo ${1:?word} # aecho ${par:?word} # -bash: par: wordpar=cecho ${par:?word} # c ${parameter:+word} 如果 parameter 为空或未设置，那么就什么都不做。不然使用 word 进行替换。 12345678set a b echo ${3:+word} # 空echo ${1:+word} # wordecho ${par:+word} # 空par=cecho ${par:+word} # word 变量切片 ${parameter:offset} ${parameter:offset:length} 和大部分编程语言字符串切片一样，offset代表偏移值，length代表字符长度，需要注意的有以下几点 起始位置为0，截取的字符串包含第一个 当不指定length时，会截取到字符串结尾 123string=01234567890abcdefghecho ${string: 1} # 1234567890abcdefghecho ${string: 1: 2} # 12 当offset小于0时，代表从尾部开始计算偏移值，开始值为-1，同时冒号和offset之间至少有一个空格避免歧义 1234string=01234567890abcdefghecho ${string: -2} # ghecho ${string:-2} # 01234567890abcdefgh 没有空格被解释成了:-echo ${string: -3:2} # fg 当length小于0时，代表的从尾部开始计算的偏移值而不是字符长度，所以表达式拓展为offset到length直接的字符，注意此时是不包括length这个字符的。 12string=01234567890abcdefghecho ${string: -7:-2} # bcdef 如果参数为@，结果是位置参数的偏移值加长度，注意此时起始计数为1(注意和上面区分)，如果offset为负值，则代表从尾部计数，length不能为负数 123456789101112string=01234567890abcdefghset -- 1 2 3 4 5 6 7 8 9 0 a b c d e f g hecho ${string:7} # 890abcdefghecho ${@:7} # 7 8 9 0 a b c d e f g h 注意和上面的区别echo ${@: 0} # 1 2 3 4 5 6 7 8 9 0 a b c d e f g hecho ${@: 1} # 1 2 3 4 5 6 7 8 9 0 a b c d e f g h 和上面结果一样echo ${string: -7} # bcdefghecho ${@: -7} # b c d e f g hecho ${@:7:-2} # bash: -2: substring expression &lt; 0 如果参数为下标是@或者*的数组，表达式被扩展为从${parameter[offset]}往后length的长度的数组。负数的offset代表从尾部开始计数。length不能为负数 123456array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h)echo ${array[@]:7} # 7 8 9 0 a b c d e f g hecho ${array[@]:7:2} # 7 8echo ${array[@]: -7:2} # b cecho ${array[@]: -7:-2} # bash: -2: substring expression &lt; 0 总结：除了位置参数是按1开始从头计算偏移值，其他都是按0开始计算偏移值的，从尾部都是按-1开始计算偏移值的 参数查找 ${!prefix*} ${!prefix@} shell将其展为所有以prefix开头为的变量。需要注意的是，当表达式被双引号包裹时，@会扩展成独立的几个变量，而*则会扩展成变量组合而成的字符串 123456789101112131415161718192021var1=abcvar2=def$ for v in ${!var@};do echo $v;done; var1var2$ for v in ${!var*};do echo $v;done;var1var2# 以上两种情况没有区别for v in \"${!var*}\";do echo $v;done;var1 var2for v in \"${!var@}\";do echo $v;done;var1var2# @的被拓展成了两个变量 ${!name[@]} ${!name[*]} 如果name是一个数组，表达式会被扩展为数组的index(键) 12arr=(a b c d e f g h)echo ${!arr[@]} # 0 1 2 3 4 5 6 7 如果name不是数组，当name已经被设置的时候，表达式被拓展为0，未被设置时被拓展为null 1234echo ${!string[*]} # 为空string=01234567890abcdefghecho ${!string[@]} # 0 在被双引号包裹的时候，@的表现和上面一样。会将变量拓展成独立的几个变量 1234567891011121314$ arr=(a b c d e f g h)$ for i in \"${!arr[*]}\";do echo $i; done;0 1 2 3 4 5 6 7$ for i in \"${!arr[@]}\";do echo $i; done;01234567 计算字符串的长度 ${#parameter} 如果parameter是字符串，表达式扩展为字符串的长度 如果parameter是*或者@，表达式扩展为参数的个数 如果parameter是一个数组名，并且下标为*或者@，表达式扩展为数组的元素个数 12345678910set a becho ${#@} # 2echo ${#1} # 1par=cecho ${#par} # 1arr=(1 2 3)echo ${#arr[@]} # 3 参数删除 ${parameter#word} ${parameter##word} 若变量内容从头开始的数据符合“关键字”，则将符合的最短(使用#)或者最长(使用##)数据删除 其中word是可以使用sh中的模式匹配，如*、?等 123456set -- ab-cd-ef ef-gh-ijecho ${1#-} # ab-cd-ef 只会从头部开始匹配，开头没有-所以就不会匹配上echo ${1#*-} # cd-efecho ${1##*-} # ef ##会匹配最长的数据 如果parameter是@或者*，则会对位置参数的每一个进行配合和删除操作，最后的结果是改变之后的参数列表 1234set -- ab-cd-ef ef-gh-ijecho ${@#*-} # cd-ef gh-ijecho ${@##*-} # ef ij 如果parameter是一个数组名，并且下标为*或者@，则匹配和删除的操作会应用到每一个数组元素中，最后的结果是改变之后的数组列表 12arr=(--a --b --c)echo ${arr[@]#-} # -a -b -c ${parameter%word} ${parameter%%word} 整体逻辑和上面的${parameter#word}、${parameter##word}差别不大，只是这两者是从尾开始匹配关键字 123456789set -- abcd-- efgh--echo ${1%-} # abcd-echo ${1%%-} # abcd-echo ${1%-?} # abcd echo ${@%-} # abcd- efgh-arr=(a-- b-- c--)echo ${arr[@]%-} # a- b- c- 字符移除可以实现一些很常见的操作： 获取文件名，文件后缀 123FILENAME=linux_bash.shecho ${FILENAME%.*} # linux_bashecho ${FILENAME##*.} # sh 获取文件路径，或者获取文件名 1234FILENAME=/home/somebody/linux_bash.shecho ${FILENAME##*/} # linux_bash.shecho ${FILENAME%/*} # /home/somebody 如上面介绍的docker-php-entrypoint.sh，判断某字符串是否以某字符开头 12345678910$ OPT='-option'$ if [ ${OPT#-} != ${OPT} ];&gt; then&gt; echo \"start with -\"&gt; else&gt; echo \"not start with -\"&gt; fistart with - 参数替换 ${parameter/pattern/string} 将parameter中出现的第一个pattern替换为string。 其中： pattern可以使用*、?、[]等通配符 1234string=abceddabceddabceddecho ${string/d?a/f} # abcefbceddabcedd 只替换了第一个ddaecho ${string/d*a/f} # abcefbcedd 替换了ddabcedda 如果pattern使用/开头, 将会用string替换所有符合的匹配项 123string=abceddabceddabceddecho ${string//d?a/f} # abcefbcefbcedd 第二个dda也被替换成了f 如果pattern使用#开头, 将会用string替换开头的匹配项，这个就是默认的表现 如果pattern使用%开头, 将会用sting替换结尾处的一个匹配项 12345string=abceddabceddabceddecho ${string/%d?a/f} # abceddabceddabcedd 注意此时并未匹配到最后一个dda，原因未知echo ${string/%dd/f} # abceddabceddabcef 替换了尾部的dd 如果string是空，那么匹配项会被删除，并忽略pattern后面的/ 12string=abceddabceddabceddecho ${string/dd/} # abceabceddabcedd 删除了第一个dd 如果通过Shopt Builtin开启了大小写不敏感，那么则可以按照忽略大小写来匹配 如果参数是@或者*，将会对每一个位置参数进行匹配替换操作 12set -- abc abd abeecho ${@/a/f} # fbc fbd fbe 如果参数是数组且以@或者*作为参数，则对数组每一个元素进行匹配替换操作 12arr=(abc abd abe)echo ${arr[@]/a/f} # fbc fbd fbe 大小写修改 ${parameter^pattern} ${parameter^^pattern} ${parameter,pattern} ${parameter,,pattern} 注：此操作仅适用于bash4.0往上版本 这些拓展用于修改字符串中的大小写。pattern表示的是匹配的模式，对于能匹配项会进行大小写转换(此处表示不理解) 小写转大写: ^会把开头的小写字母转换成大写，^^会转换所有小写成大写 1234par='abc'echo ${par^} # Abcecho ${par^^} # ABC 大写转小写: ,会把开头的大写转换成小写，,,会把所以大写转换成小写 1234par='ABC'echo ${par,} # aBCecho ${par,,} # abc 参数是@或者*，会对每一个位置参数进行转换 123set -- ABC DEF HIJecho ${@,} # aBC dEF hIJecho ${@,,} # abc def hij 对于下标是@或者*的数组，大小写转换会应用于每一个数组元素 1234arr=(ABC DEF HIJ)echo ${arr[@],} # aBC dEF hIJecho ${arr[@],,} # abc def hij 变量操作 ${parameter@operator} 注：此操作仅适用于bash4.0往上版本 此拓展根据操作符(operator)执行参数转换或者，操作符如下 Q 将字符串使用引号包裹 12par='abc def'echo ${par@Q} # 'abc def' E 对于使用反斜线\\后的字符一律按转义处理 1234567891011# 对于双引号包裹的字符串par=\"abc\\\"u\"echo ${par} # abc\"u 按照转义解释echo ${par@E} # abc\"u 按照转义解释# 对于双引号包裹的字符串par=\"abc\\'u\"echo ${par} # abc\\'u 此时单引号不需要转义，所以展示了\\echo ${par@E} # abc'u E操作，继续按照转义来解释了\\ P 如果parameter含有prompt string时，按照prompt解释（默认按照字符串解释） 1234par=\"\\@-abcd-\\u\"echo ${par} # \\@-abcd-\\uecho ${par@P} # 05:09 AM-abcd-I have no name! A 拓展成参数赋值的语句 12345a=2par=$a+1echo ${par} # 2+1echo ${par@A} # par='2+1' 此时$a已经被解释成实际值了 a 由参数属性值组成的字符串 对于@和*，此操作会对每一个位置参数进行处理 对于下标为@或*的数组，此操作会对每一个数组元素进行处理 参考： Bash Reference Manual#Shell-Expansions shell，exec，source执行脚本的区别 whats-set-progname-means-in-shell-script Shell 中的命令替换及参数扩展","link":"/2019/05/13/shell_parameter_expansion/"}],"tags":[{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"bufio","slug":"bufio","link":"/tags/bufio/"},{"name":"BFC","slug":"BFC","link":"/tags/BFC/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"commonJS","slug":"commonJS","link":"/tags/commonJS/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"prototype","slug":"prototype","link":"/tags/prototype/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"Template","slug":"Template","link":"/tags/Template/"},{"name":"Render","slug":"Render","link":"/tags/Render/"},{"name":"net&#x2F;http","slug":"net-http","link":"/tags/net-http/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"postMessage","slug":"postMessage","link":"/tags/postMessage/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"paramater","slug":"paramater","link":"/tags/paramater/"},{"name":"pointer","slug":"pointer","link":"/tags/pointer/"},{"name":"redis-cli","slug":"redis-cli","link":"/tags/redis-cli/"},{"name":"protocol","slug":"protocol","link":"/tags/protocol/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"macro","slug":"macro","link":"/tags/macro/"},{"name":"stringification","slug":"stringification","link":"/tags/stringification/"},{"name":"iptables","slug":"iptables","link":"/tags/iptables/"},{"name":"SNAT","slug":"SNAT","link":"/tags/SNAT/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"parameter expansion","slug":"parameter-expansion","link":"/tags/parameter-expansion/"},{"name":"php","slug":"php","link":"/tags/php/"}],"categories":[{"name":"golang","slug":"golang","link":"/categories/golang/"},{"name":"FRONTEND","slug":"FRONTEND","link":"/categories/FRONTEND/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"BACKEND","slug":"BACKEND","link":"/categories/BACKEND/"},{"name":"backend","slug":"backend","link":"/categories/backend/"}]}