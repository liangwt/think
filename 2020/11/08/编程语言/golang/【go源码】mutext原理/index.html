<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【go源码】mutext原理.md - Liangwt&#039;s Share</title><meta description="Mutex结构type Mutex struct &amp;amp;#123;  state int32  sema  uint32&amp;amp;#125;   state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 state位含义const (  mutexLocked &amp;#x3D; 1 &amp;lt;&amp;lt; iota &amp;#x2F;&amp;#x2F; mutex is locked  mutexWoken  &amp;#x2F;&amp;#x2F;2  mutexStarvi"><meta property="og:type" content="blog"><meta property="og:title" content="【go源码】mutext原理.md"><meta property="og:url" content="https://blog.showthink.cn/2020/11/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E3%80%90go%E6%BA%90%E7%A0%81%E3%80%91mutext%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="Liangwt&#039;s Share"><meta property="og:description" content="Mutex结构type Mutex struct &amp;amp;#123;  state int32  sema  uint32&amp;amp;#125;   state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 state位含义const (  mutexLocked &amp;#x3D; 1 &amp;lt;&amp;lt; iota &amp;#x2F;&amp;#x2F; mutex is locked  mutexWoken  &amp;#x2F;&amp;#x2F;2  mutexStarvi"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.showthink.cn/img/og_image.png"><meta property="article:published_time" content="2020-11-08T06:29:51.000Z"><meta property="article:modified_time" content="2020-11-08T06:47:08.047Z"><meta property="article:author" content="wentao.liang"><meta property="article:tag" content="go 源码"><meta property="article:tag" content="mutex"><meta property="article:tag" content="同步"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.showthink.cn/2020/11/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E3%80%90go%E6%BA%90%E7%A0%81%E3%80%91mutext%E5%8E%9F%E7%90%86/"},"headline":"Liangwt's Share","image":["https://blog.showthink.cn/img/og_image.png"],"datePublished":"2020-11-08T06:29:51.000Z","dateModified":"2020-11-08T06:47:08.047Z","author":{"@type":"Person","name":"wentao.liang"},"description":"Mutex结构type Mutex struct &amp;#123;  state int32  sema  uint32&amp;#125;   state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 state位含义const (  mutexLocked &#x3D; 1 &lt;&lt; iota &#x2F;&#x2F; mutex is locked  mutexWoken  &#x2F;&#x2F;2  mutexStarvi"}</script><link rel="canonical" href="https://blog.showthink.cn/2020/11/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E3%80%90go%E6%BA%90%E7%A0%81%E3%80%91mutext%E5%8E%9F%E7%90%86/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.14.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-ligth.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Liangwt&#039;s Share" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-11-08T06:29:51.000Z" title="2020-11-08T06:29:51.000Z">2020-11-08</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Go/">编程语言 / Go</a></span><span class="level-item">22 分钟 读完 (大约 3269 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">【go源码】mutext原理.md</h1><div class="content"><h2 id="Mutex结构"><a href="#Mutex结构" class="headerlink" title="Mutex结构"></a><strong><code>Mutex</code>结构</strong></h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>  state <span class="hljs-keyword">int32</span><br>  sema  <span class="hljs-keyword">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p> <code>state</code> 表示当前互斥锁的状态，而 <code>sema</code> 是用于控制锁状态的信号量。</p>
<h2 id="state位含义"><a href="#state位含义" class="headerlink" title="state位含义"></a><code>state</code>位含义</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>  mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked</span><br>  mutexWoken  <span class="hljs-comment">//2</span><br>  mutexStarving <span class="hljs-comment">//4</span><br>  mutexWaiterShift = <span class="hljs-literal">iota</span> <span class="hljs-comment">//3</span><br>)<br>                                                                                             <br><span class="hljs-number">32</span>                                               <span class="hljs-number">3</span>             <span class="hljs-number">2</span>             <span class="hljs-number">1</span>             <span class="hljs-number">0</span> <br> |                                               |             |             |             | <br> |                                               |             |             |             | <br> v-----------------------------------------------v-------------v-------------v-------------+ <br> |                                               |             |             |             v <br> |                 waitersCount                  |mutexStarving| mutexWoken  | mutexLocked | <br> |                                               |             |             |             | <br> +-----------------------------------------------+-------------+-------------+-------------+<br></code></pre></td></tr></table></figure>

<p>在默认情况下，互斥锁的所有状态位都是 <code>0</code>，<code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
<li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li>
</ul>
<a id="more"></a>

<h2 id="Lock原理"><a href="#Lock原理" class="headerlink" title="Lock原理"></a>Lock原理</h2><h3 id="互斥锁的两种模式"><a href="#互斥锁的两种模式" class="headerlink" title="互斥锁的两种模式"></a>互斥锁的两种模式</h3><blockquote>
<p>互斥锁有两种模式：正常模式和饥饿模式。</p>
<p>在正常模式下，所有等待锁的goroutine按照<strong>FIFO</strong>顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式。</p>
<p>在饥饿模式下，锁的所有权将从unlock的gorutine直接交给交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</p>
<p>如果一个等待的goroutine获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。</p>
<p>正常模式有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p>
</blockquote>
<h3 id="状态1：m-state-0"><a href="#状态1：m-state-0" class="headerlink" title="状态1：m.state == 0"></a>状态1：m.state == 0</h3><p>如果当前 state == 0, 肯定是没人上锁，也没人等待。这时只要把<code>state</code>的 <code>mutexLocked</code>位置1即可，以上使用cas操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="状态2：符合自旋条件"><a href="#状态2：符合自旋条件" class="headerlink" title="状态2：符合自旋条件"></a>状态2：符合自旋条件</h3><p>对于符合条件的场景将使用自旋来进行抢锁，但如果当前处于饥饿模式禁止自旋。根据实现原理，此时活跃的 goroutine 要直接进入 park 的队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-comment">// 第一个条件是state已被锁，但是不是饥饿状态。如果时饥饿状态，自旋时没有用的，锁的拥有权直接交给了等待队列的第一个。</span><br>  <span class="hljs-comment">// 第二个条件是还可以自旋，多核、压力不大并且在一定次数内可以自旋， 具体的条件可以参考`sync_runtime_canSpin`的实现。</span><br>  <span class="hljs-comment">// 如果满足这两个条件，不断自旋来等待锁被释放、或者进入饥饿状态、或者不能再自旋。</span><br>  <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<br>    <span class="hljs-comment">// 自旋的过程中如果发现state还没有设置woken标识，则设置它的woken标识， 并标记自己为被唤醒。</span><br>    <span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>    	atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>      awoke = <span class="hljs-literal">true</span><br>    &#125;<br>    runtime_doSpin()<br>    iter++<br>    old = m.state<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br>  <span class="hljs-comment">// ... 使用信号量抢锁逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="状态3：使用信号量抢锁"><a href="#状态3：使用信号量抢锁" class="headerlink" title="状态3：使用信号量抢锁"></a>状态3：使用信号量抢锁</h3><p>对于不符合自旋条件的状态，开始尝试使用信号量抢锁，主要分为两个步骤，先记录开始抢锁时的<code>state</code> 记做 <code>old</code>，然后根据不同情况计算如果抢锁成功之后的<code>state</code>值，最后通过cas更新</p>
<h4 id="1、计算互斥锁的最新状态"><a href="#1、计算互斥锁的最新状态" class="headerlink" title="1、计算互斥锁的最新状态"></a>1、计算互斥锁的最新状态</h4><p><strong>计算1</strong></p>
<p>如果old state状态不是饥饿状态, new state 设置锁， 尝试通过CAS获取锁</p>
<p>如果old state状态是饥饿状态, 则不设置new state的锁，因为饥饿状态下锁直接转给等待队列的第一个.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-built_in">new</span> |= mutexLocked<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>计算2</strong></p>
<p>如果此时的old的值 <code>mutexLocked</code>不是1，或者是饥饿模式，说明有人己经锁上了，需要把<code>waitersCount</code>++</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>计算3</strong></p>
<p>如果当前goroutine已经处于饥饿状态， 并且old state的已被加锁<br>将new state的状态标记为饥饿状态, 将锁转变为饥饿状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<br>	<span class="hljs-built_in">new</span> |= mutexStarving<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2、更新互斥锁的状态并获取锁"><a href="#2、更新互斥锁的状态并获取锁" class="headerlink" title="2、更新互斥锁的状态并获取锁"></a>2、更新互斥锁的状态并获取锁</h4><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-comment">// ... 自旋</span><br>  <span class="hljs-comment">// ... 设置new新值</span><br><br>  <span class="hljs-comment">// 通过CAS设置new state值.</span><br>  <span class="hljs-comment">// 注意new的锁标记不一定是true, 也可能只是标记一下锁的state是饥饿状态.</span><br>  <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>    <span class="hljs-comment">// ... 获取锁逻辑</span><br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果CAS不成功，重新获取锁的state, 从for循环开始处重新开始</span><br>    old = m.state<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>设锁成功</strong></p>
<p>state的新值锁标记不一定是true，  如果old state的状态是未被锁状态，并且锁不处于饥饿状态, 那么当前goroutine已经获取了锁的拥有权，跳出循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-comment">// ... 自旋</span><br>  <span class="hljs-comment">// ... 设置new新值</span><br><br>  <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>    <span class="hljs-comment">// 成功获取锁逻辑</span><br>    <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">break</span><br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果CAS不成功，重新获取锁的state, 从for循环开始处重新开始</span><br>    old = m.state<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用信号量并让goroutine休眠</strong></p>
<p>对于被唤醒的goroutine，会被放到信号量等待的队首。对于新来的goroutine，会被放到信号量等待的队尾。信号量会按照FIFO的方式唤醒goroutine</p>
<blockquote>
<p>并不意味着在队首被唤醒时就一定能拿到锁，它需要和当前正在请求锁的goroutine一起竞争。</p>
<p>所以才会设计出饥饿模式，在饥饿模式下，新的goroutine不会竞争，因此可以保证队首的goroutine在被唤醒时一定能拿到锁</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-comment">// ... 自旋</span><br>  <span class="hljs-comment">// ... 设置new新值</span><br><br>  <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>    <span class="hljs-comment">// ... 成功获取锁逻辑</span><br>    <span class="hljs-comment">// 设置/计算本goroutine的等待时间</span><br>    queueLifo := waitStartTime != <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;<br>      waitStartTime = runtime_nanotime()<br>    &#125;<br><br>    <span class="hljs-comment">// 既然未能获取到锁， 那么就使用sleep原语阻塞本goroutine</span><br>    <span class="hljs-comment">// 如果是新来的goroutine,queueLifo=false, 加入到等待队列的尾部，耐心等待</span><br>    <span class="hljs-comment">// 如果是唤醒的goroutine, queueLifo=true, 加入到等待队列的头部</span><br>    runtime_SemacquireMutex(&amp;m.sema, queueLifo)<br><br>    <span class="hljs-comment">// ... </span><br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果CAS不成功，重新获取锁的state, 从for循环开始处重新开始</span><br>    old = m.state<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>唤醒之后</strong></p>
<ol>
<li><code>runtime_SemacquireMutex</code> 被唤醒了有两种情况，如果老的 old 就是饥饿的，那么自己一定是唯一被唤醒，一定能抢到锁的，waiter 减一，如果自己是最后一个 waiter 或是饥饿时间小于 starvationThresholdNs 那么清除 mutexStarving 标记位后退出</li>
<li>如果老的不是饥饿模式，那么 awoke 置 true，重新竞争</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-comment">// ... 自旋</span><br>  <span class="hljs-comment">// ... 设置new新值</span><br><br>  <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>    <span class="hljs-comment">// ... 成功获取锁逻辑</span><br>    <span class="hljs-comment">// ... 设置/计算本goroutine的等待时间</span><br>    <span class="hljs-comment">// ... 信号量休眠</span><br>    <br>    <span class="hljs-comment">// sleep之后，此goroutine被唤醒</span><br>    <br>    <span class="hljs-comment">// 计算当前goroutine是否已经处于饥饿状态.</span><br>    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br>    <span class="hljs-comment">// 得到当前的锁状态</span><br>    old = m.state<br><br>    <span class="hljs-comment">// 如果当前的state已经是饥饿状态</span><br>    <span class="hljs-comment">// 那么锁应该处于Unlock状态，那么应该是锁被直接交给了本goroutine</span><br>    <span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;<br><br>      <span class="hljs-comment">// 如果当前的state已被锁，或者已标记为唤醒， 或者等待的队列中不为空,</span><br>      <span class="hljs-comment">// 那么state是一个非法状态</span><br>      <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;<br>        throw(<span class="hljs-string">"sync: inconsistent mutex state"</span>)<br>      &#125;<br><br>      <span class="hljs-comment">// 当前goroutine用来设置锁，并将等待的goroutine数减1.</span><br>      delta := <span class="hljs-keyword">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)<br><br>      <span class="hljs-comment">// 如果本goroutine是最后一个等待者，或者它并不处于饥饿状态，</span><br>      <span class="hljs-comment">// 那么我们需要把锁的state状态设置为正常模式.</span><br>      <span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-comment">// 退出饥饿模式</span><br>        delta -= mutexStarving<br>      &#125;<br><br>      <span class="hljs-comment">// 设置新state, 因为已经获得了锁，退出、返回</span><br>      atomic.AddInt32(&amp;m.state, delta)<br>      <span class="hljs-keyword">break</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前的锁是正常模式，本goroutine被唤醒，自旋次数清零，从for循环开始处重新开始</span><br>    awoke = <span class="hljs-literal">true</span><br>    iter = <span class="hljs-number">0</span><br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果CAS不成功，重新获取锁的state, 从for循环开始处重新开始</span><br>    old = m.state<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然在唤醒之后还需要计算是不是已经达到了饥饿模式的触发条件，如果时间超过的1ms则设置变量 starving = true，这样下次计算new state的时候就会把饥饿位标置了(计算2)</p>
<h2 id="UnLock原理"><a href="#UnLock原理" class="headerlink" title="UnLock原理"></a>UnLock原理</h2><h3 id="步骤1：原子操作"><a href="#步骤1：原子操作" class="headerlink" title="步骤1：原子操作"></a>步骤1：原子操作</h3><p>如果state不是处于锁的状态, 那么就是Unlock根本没有加锁的mutex, panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123;<br>  throw(<span class="hljs-string">"sync: unlock of unlocked mutex"</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="步骤2：通知其他goroutine"><a href="#步骤2：通知其他goroutine" class="headerlink" title="步骤2：通知其他goroutine"></a>步骤2：通知其他goroutine</h3><p>在哪种情况需要通知其他goroutine呢，当然是new != 0时</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-comment">// Outlined slow path to allow inlining the fast path.</span><br>  <span class="hljs-comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span><br>  m.unlockSlow(<span class="hljs-built_in">new</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="步骤2-1：对于饥饿模式，使用信号量释放锁"><a href="#步骤2-1：对于饥饿模式，使用信号量释放锁" class="headerlink" title="步骤2.1：对于饥饿模式，使用信号量释放锁"></a>步骤2.1：对于饥饿模式，使用信号量释放锁</h4><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>	<span class="hljs-comment">// ... 正常模式</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 饥饿模式下， 直接将锁的拥有权传给等待队列中的第一个 (true 参数)</span><br>  <span class="hljs-comment">// 注意此时state的mutexLocked还没有加锁，唤醒的goroutine会设置它。</span><br>  <span class="hljs-comment">// 在此期间，如果有新的goroutine来请求锁， 因为mutex处于饥饿状态， mutex还是被认为处于锁状态，</span><br>  <span class="hljs-comment">// 新来的goroutine不会把锁抢过去</span><br>  runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="步骤2-2：正常模式下，cas-state"><a href="#步骤2-2：正常模式下，cas-state" class="headerlink" title="步骤2.2：正常模式下，cas state"></a>步骤2.2：正常模式下，cas state</h4><p>为什么是 for 循环？原因在于，上一步原子操作后，很可能有第三方刚好获得锁了，那么 for 里面的 CAS 肯定会失败，所以需要循环试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>  old := <span class="hljs-built_in">new</span><br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 如果 old&amp;(mutexLocked|mutexWoken) != 0 说明要么有人获得了锁，</span><br>    <span class="hljs-comment">// 要么己经有 woken 的 goroutine 了，也不用去唤醒</span><br>    <span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>   	<br>    <span class="hljs-comment">// 设置新的state, 这里通过信号量会唤醒一个阻塞的goroutine去获取锁.</span><br>    <span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken<br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>      runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    old = m.state<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// ... 饥饿模式</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="go中的底层同步机制"><a href="#go中的底层同步机制" class="headerlink" title="go中的底层同步机制"></a>go中的底层同步机制</h3><h4 id="1-cas、atomic"><a href="#1-cas、atomic" class="headerlink" title="1 cas、atomic"></a>1 cas、atomic</h4><p>cas(Compare And Swap)和原子运算是其他同步机制的基础， 在runtime/asm_xxx.s(xxx代表系统架构，比如amd64)中实现。amd64架构的系统中， 主要通过两条汇编语句来实现，一个是<strong>LOCK</strong>、一个是<strong>CMPXCHG</strong>。</p>
<p><strong>LOCK</strong>是一个指令前缀，其后必须跟一条“读-改-写”的指令，比如INC、XCHG、CMPXCHG等。 这条指令对CPU缓存的访问将是排他的。</p>
<p><strong>CMPXCHG</strong>是完成CAS动作的指令。 把LOCK和CMPXCHG一起使用，就达到了原子CAS的功能。</p>
<p>atomic操作也是通过<strong>LOCK</strong>和其他算术操作（<strong>XADD</strong>、<strong>ORB</strong>等）组合来实现。</p>
<h4 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2 自旋锁"></a>2 自旋锁</h4><p>Golang中的自旋锁用来实现其他类型的锁，自旋锁的作用和互斥量类似，不同点在于， 它不是通过休眠来使进程阻塞，而是在获得锁之前一直处于忙等状态（自旋），从而避免了进程（或者</p>
<p>和自旋锁相关的函数有sync_runtime_canSpin和sync_runtime_doSpin， 前者用来判断当前是否可以进行自旋，后者执行自旋操作。二者通常一起使用。</p>
<p>sync_runtime_canSpin函数中在以下四种情况返回false</p>
<ol>
<li>已经执行了很多次</li>
<li>是单核CPU</li>
<li>没有其他正在运行的P</li>
<li>当前<strong>P</strong>的<strong>G</strong>队列为空</li>
</ol>
<p>条件1避免长时间自旋浪费CPU的情况。</p>
<p>条件2、3用来保证除了当前在运行的Goroutine之外，还有其他Goroutine在运行。</p>
<p>条件4是避免自旋锁等待的条件是由当前<strong>P</strong>的其他<strong>G</strong>来触发，这样会导致在自旋变得没有意义，因为条件永远无法触发。</p>
<p><code>sync_runtime_doSpin</code>会调用procyield函数，该函数也是汇编语言实现。 函数内部循环调用<strong>PAUSE</strong>指令。<strong>PAUSE</strong>指令什么都不做，但是会消耗CPU时间，在执行<strong>PAUSE</strong>指令时， CPU不会对他做不必要的优化。</p>
<h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3 信号量"></a>3 信号量</h4><p>按照runtime/sema.go中的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs text">Think of them as a way to implement sleep and wakeup<br></code></pre></td></tr></table></figure>

<p>Golang中的sema，提供了休眠和唤醒Goroutine的功能。</p>
<p>*<em>semacquire *</em>函数首先检查信号量是否为0：如果大于0，让信号量减一，返回； 如果等于0，就调用<code>goparkunlock</code>函数，把当前Goroutine放入该sema的等待队列，并把他设为等待状态。</p>
<p><strong>semrelease</strong> 函数首先让信号量加一，然后检查是否有正在等待的Goroutine： 如果没有，直接返回；如果有，调用<code>goready</code>函数唤醒一个Goroutine。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://ga0.github.io/golang/2015/10/11/golang-sync.html">Golang同步机制的实现</a></p>
</li>
<li><p><a href="https://colobu.com/2018/12/18/dive-into-sync-mutex/">sync.mutex 源代码分析</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/ce1553cc5b4f">GO: sync.Mutex 的实现与演进</a></p>
</li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/go-%E6%BA%90%E7%A0%81/">go 源码</a><a class="link-muted mr-2" rel="tag" href="/tags/mutex/">mutex</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE%E9%9B%86%E5%90%88/%E7%9B%B4%E6%96%B9%E5%9B%BE&amp;%E9%9D%A2%E7%A7%AF%20/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">数据结构与算法/题目集合/直方图&amp;面积 </span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++/container%20and%20container%20adapter/"><span class="level-item">STL Container and Container Adaptor Classes: A Summary</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: 'a07881ada4cccda8c85174551f9dbb3e',
            repo: 'think',
            owner: 'liangwt',
            clientID: '3760ccdf8326f0e9e0b2',
            clientSecret: '8e98b8fcb60af6f3c2e16169952f2637beb43610',
            admin: ["liangwt"],
            createIssueManually: false,
            distractionFreeMode: true,
            perPage: 20,
            pagerDirection: 'last',
            
            
            enableHotKey: true
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-3-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#Mutex结构"><span class="mr-2">1</span><span>Mutex结构</span></a></li><li><a class="is-flex" href="#state位含义"><span class="mr-2">2</span><span>state位含义</span></a></li><li><a class="is-flex" href="#Lock原理"><span class="mr-2">3</span><span>Lock原理</span></a><ul class="menu-list"><li><a class="is-flex" href="#互斥锁的两种模式"><span class="mr-2">3.1</span><span>互斥锁的两种模式</span></a></li><li><a class="is-flex" href="#状态1：m-state-0"><span class="mr-2">3.2</span><span>状态1：m.state == 0</span></a></li><li><a class="is-flex" href="#状态2：符合自旋条件"><span class="mr-2">3.3</span><span>状态2：符合自旋条件</span></a></li><li><a class="is-flex" href="#状态3：使用信号量抢锁"><span class="mr-2">3.4</span><span>状态3：使用信号量抢锁</span></a><ul class="menu-list"><li><a class="is-flex" href="#1、计算互斥锁的最新状态"><span class="mr-2">3.4.1</span><span>1、计算互斥锁的最新状态</span></a></li><li><a class="is-flex" href="#2、更新互斥锁的状态并获取锁"><span class="mr-2">3.4.2</span><span>2、更新互斥锁的状态并获取锁</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#UnLock原理"><span class="mr-2">4</span><span>UnLock原理</span></a><ul class="menu-list"><li><a class="is-flex" href="#步骤1：原子操作"><span class="mr-2">4.1</span><span>步骤1：原子操作</span></a></li><li><a class="is-flex" href="#步骤2：通知其他goroutine"><span class="mr-2">4.2</span><span>步骤2：通知其他goroutine</span></a><ul class="menu-list"><li><a class="is-flex" href="#步骤2-1：对于饥饿模式，使用信号量释放锁"><span class="mr-2">4.2.1</span><span>步骤2.1：对于饥饿模式，使用信号量释放锁</span></a></li><li><a class="is-flex" href="#步骤2-2：正常模式下，cas-state"><span class="mr-2">4.2.2</span><span>步骤2.2：正常模式下，cas state</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#拓展"><span class="mr-2">5</span><span>拓展</span></a><ul class="menu-list"><li><a class="is-flex" href="#go中的底层同步机制"><span class="mr-2">5.1</span><span>go中的底层同步机制</span></a><ul class="menu-list"><li><a class="is-flex" href="#1-cas、atomic"><span class="mr-2">5.1.1</span><span>1 cas、atomic</span></a></li><li><a class="is-flex" href="#2-自旋锁"><span class="mr-2">5.1.2</span><span>2 自旋锁</span></a></li><li><a class="is-flex" href="#3-信号量"><span class="mr-2">5.1.3</span><span>3 信号量</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#参考"><span class="mr-2">6</span><span>参考</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-12-20T07:13:54.000Z">2020-12-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/intrusive-list/">intrusive list</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构与算法 / 数据结构</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-13T15:43:15.000Z">2020-11-13</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E3%80%90go%E6%BA%90%E7%A0%81%E3%80%91channel%E5%8E%9F%E7%90%86/">【go源码】channel原理</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Go/">编程语言 / Go</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-08T06:47:08.035Z">2020-11-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE%E9%9B%86%E5%90%88/%E7%9B%B4%E6%96%B9%E5%9B%BE&amp;%E9%9D%A2%E7%A7%AF%20/">数据结构与算法/题目集合/直方图&amp;面积 </a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-08T06:29:51.000Z">2020-11-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E3%80%90go%E6%BA%90%E7%A0%81%E3%80%91mutext%E5%8E%9F%E7%90%86/">【go源码】mutext原理.md</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Go/">编程语言 / Go</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-06T11:57:25.000Z">2020-09-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++/container%20and%20container%20adapter/">STL Container and Container Adaptor Classes: A Summary</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/">编程语言 / C++</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Liangwt&#039;s Share" height="28"></a><p class="size-small"><span>&copy; 2020 wentao.liang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://blog.showthink.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>